<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Revit Viewer</title>
    <!-- Google Fonts for Modern Feel -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Appearance */
            --bg-app: #09090b;
            /* Deep Void */
            --glass-base: rgba(15, 23, 42, 0.75);
            --glass-border: rgba(255, 255, 255, 0.08);
            --glass-highlight: rgba(255, 255, 255, 0.05);

            /* Typography */
            --font-main: 'Outfit', sans-serif;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;

            /* Brand / Dopamine Colors */
            --primary: #3b82f6;
            --primary-gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            --accent: #8b5cf6;
            --accent-gradient: linear-gradient(135deg, #8b5cf6 0%, #d946ef 100%);

            /* Utility */
            --radius-lg: 16px;
            --radius-md: 10px;
            --radius-sm: 6px;
            --shadow-float: 0 10px 40px -10px rgba(0, 0, 0, 0.5);
            --transition-bounce: cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            outline: none;
        }

        body {
            font-family: var(--font-main);
            background: var(--bg-app);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            user-select: none;
        }

        /* --- LAYOUT & CANVAS --- */
        #three-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
        }

        /* Floating Panels Common Styles */
        .glass-panel {
            background: var(--glass-base);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-float);
            border-radius: var(--radius-lg);
            color: var(--text-primary);
            transition: transform 0.2s ease, opacity 0.2s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .glass-panel:hover {
            border-color: rgba(255, 255, 255, 0.15);
        }

        /* --- SIDEBARS --- */
        .sidebar {
            position: absolute;
            top: 20px;
            bottom: 20px;
            width: 280px;
            z-index: 10;
        }

        .sidebar.left {
            left: 20px;
        }

        .sidebar.right {
            right: 20px;
        }

        .panel-header {
            padding: 16px;
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: var(--text-muted);
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* --- PROJECT BROWSER --- */
        .tree-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            margin-bottom: 2px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.2s var(--transition-bounce);
        }

        .tree-item:hover {
            background: var(--glass-highlight);
            color: var(--text-primary);
            transform: translateX(4px);
        }

        .tree-item.selected {
            background: rgba(59, 130, 246, 0.15);
            color: var(--primary);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .tree-item-icon {
            width: 20px;
            text-align: center;
        }

        .tree-children {
            padding-left: 20px;
            border-left: 1px solid var(--glass-border);
            margin-left: 14px;
        }

        /* --- FILTERS --- */
        .filter-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: background 0.1s;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .filter-item:hover {
            background: var(--glass-highlight);
            color: var(--text-primary);
        }

        .filter-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
        }

        /* Modern Switch Toggle */
        .toggle-switch {
            position: relative;
            display: inline-flex;
            width: 32px;
            height: 18px;
            flex-shrink: 0;
            margin-right: 6px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
            margin: 0;
        }

        .toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.1);
            transition: .3s;
            border-radius: 18px;
            border: 1px solid var(--glass-border);
            pointer-events: none;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 12px;
            width: 12px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-muted);
            transition: .3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked+.toggle-slider {
            background-color: var(--primary);
            border-color: var(--primary);
        }

        .toggle-switch input:checked+.toggle-slider:before {
            transform: translateX(14px);
            background-color: white;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        }

        /* --- PROPERTIES & LEGEND --- */
        .property-group {
            margin-bottom: 12px;
        }

        .property-group-header {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            padding: 4px 8px;
            margin-bottom: 4px;
        }

        .property-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            font-size: 12px;
        }

        .property-name {
            color: var(--text-secondary);
        }

        .property-value {
            color: var(--text-primary);
            font-weight: 500;
            text-align: right;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        /* --- FLOATING COMMAND BAR --- */
        .command-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            backdrop-filter: blur(16px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .cmd-btn {
            width: 44px;
            height: 44px;
            border-radius: 14px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s var(--transition-bounce);
        }

        .cmd-btn svg {
            width: 22px;
            height: 22px;
            fill: currentColor;
        }

        .cmd-btn:hover {
            background: var(--glass-highlight);
            color: var(--text-primary);
            transform: translateY(-4px);
        }

        .cmd-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.5);
        }

        .cmd-btn.primary-action {
            background: var(--primary-gradient);
            color: white;
            width: 56px;
            height: 56px;
            margin: -6px 8px;
            border-radius: 18px;
            box-shadow: 0 10px 25px rgba(37, 99, 235, 0.4);
        }

        .cmd-btn.primary-action:hover {
            box-shadow: 0 15px 35px rgba(37, 99, 235, 0.6);
            transform: translateY(-6px) scale(1.05);
        }

        .separator {
            width: 1px;
            height: 24px;
            background: var(--glass-border);
            margin: 0 4px;
        }

        /* --- WELCOME SCREEN --- */
        .welcome-screen {
            position: absolute;
            inset: 0;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
        }

        .hero-title {
            font-size: 3.5rem;
            font-weight: 700;
            background: linear-gradient(to right, #60a5fa, #c084fc);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
            letter-spacing: -1.5px;
        }

        .drop-zone-xl {
            margin-top: 40px;
            width: 400px;
            height: 220px;
            border: 2px dashed rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.02);
            position: relative;
            overflow: hidden;
        }

        .drop-zone-xl:hover {
            border-color: var(--primary);
            background: rgba(59, 130, 246, 0.05);
            transform: scale(1.02);
        }

        .drop-zone-xl.drag-over {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }

        /* --- LOADING & OVERLAYS --- */
        #loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(9, 9, 11, 0.85);
            backdrop-filter: blur(12px);
            z-index: 100;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        #drop-overlay {
            position: absolute;
            inset: 0;
            background: rgba(59, 130, 246, 0.9);
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        #drop-overlay.active {
            display: flex;
            animation: fadeIn 0.2s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* Stats & Widgets */
        .overlay-widget {
            position: absolute;
            background: rgba(15, 23, 42, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 11px;
            font-family: 'Outfit', sans-serif;
            color: var(--text-muted);
            border: 1px solid var(--glass-border);
            pointer-events: none;
            z-index: 5;
            backdrop-filter: blur(8px);
        }

        .stats-widget {
            top: 20px;
            right: 320px;
            display: flex;
            gap: 16px;
        }

        .coord-widget {
            bottom: 100px;
            right: 20px;
            text-align: right;
        }

        .tooltip {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            border: 1px solid var(--glass-border);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 9000;
            max-width: 280px;
        }
    </style>
</head>

<body>

    <!-- 3D Viewport -->
    <div id="three-container"></div>

    <!-- LEFT PANEL: Project Browser -->
    <aside class="sidebar left glass-panel" id="left-sidebar">
        <div class="panel-header">
            <span>Project Explorer</span>
        </div>
        <div class="panel-content" id="project-browser">
            <div style="text-align:center; padding: 40px 20px; color: var(--text-muted);">
                <div style="font-size: 24px; margin-bottom: 10px; opacity: 0.5;">üìÇ</div>
                No Data
            </div>
        </div>
        <div class="panel-header" style="border-top: 1px solid var(--glass-border);">
            <span>System Filters</span>
        </div>
        <div class="panel-content" id="system-filters" style="flex: 0 0 180px;">
            <div style="padding: 10px; color: var(--text-muted); font-size: 12px;">Waiting for data...</div>
        </div>
    </aside>

    <!-- RIGHT PANEL: Properties -->
    <aside class="sidebar right glass-panel">
        <div class="panel-header">
            <span>Properties</span>
        </div>
        <div class="panel-content" id="properties-panel">
            <div style="text-align:center; padding: 40px 20px; color: var(--text-muted);">
                <div style="font-size: 24px; margin-bottom: 10px; opacity: 0.5;">‚ÑπÔ∏è</div>
                Select element
            </div>
        </div>

        <div class="panel-header" style="border-top: 1px solid var(--glass-border);">
            <span>Legend</span>
        </div>
        <div class="panel-content" id="legend-items" style="flex: 0 0 150px;">
        </div>
    </aside>

    <!-- CENTER FLOATING COMMAND BAR -->
    <div class="command-bar">
        <button class="cmd-btn" onclick="fitToView()" title="Reset View (5 o'clock)">
            <svg viewBox="0 0 24 24">
                <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
            </svg>
        </button>

        <div class="separator"></div>

        <!-- Primary Action -->
        <button class="cmd-btn primary-action" onclick="document.getElementById('file-input').click()"
            title="Open File">
            <svg viewBox="0 0 24 24">
                <path
                    d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 2l5 5h-5V4zm-3 9h4v2h-4v-2zm0 4h4v2h-4v-2z" />
            </svg>
        </button>

        <div class="separator"></div>

        <button class="cmd-btn" id="wireframe-btn" onclick="toggleWireframe()" title="Wireframe">
            <svg viewBox="0 0 24 24">
                <path d="M3 3h18v18H3V3zm2 2v14h14V5H5zm4 4h6v6H9V9z" />
            </svg>
        </button>
        <button class="cmd-btn" id="xray-btn" onclick="toggleTransparency()" title="X-Ray">
            <svg viewBox="0 0 24 24">
                <path
                    d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" />
            </svg>
        </button>

    </div>

    <!-- WELCOME SCREEN -->
    <div class="welcome-screen" id="welcome-screen">
        <div style="font-size: 72px; margin-bottom: 24px;">‚ú®</div>
        <div class="hero-title">Revit Viewer</div>
        <div style="color: var(--text-secondary); font-size: 16px; margin-bottom: 40px;">Professional MEP Visualization
            Environment</div>

        <div class="drop-zone-xl" id="welcome-drop-zone">
            <svg style="width: 48px; height: 48px; opacity: 0.6; margin-bottom: 16px; fill: white;" viewBox="0 0 24 24">
                <path
                    d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z" />
            </svg>
            <div style="font-weight: 600; font-size: 18px; margin-bottom: 8px;">Drop JSON model here</div>
            <div style="font-size: 13px; color: var(--text-muted);">or click to browse</div>
        </div>
    </div>

    <!-- LOADING -->
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div style="margin-top: 20px; font-weight: 500;" id="loading-text">Processing Geometry...</div>
    </div>

    <!-- DROP OVERLAY -->
    <div id="drop-overlay">
        <div style="font-size: 64px; color: white; margin-bottom: 20px; pointer-events: none;">üìÇ</div>
        <div style="font-size: 32px; font-weight: bold; color: white; pointer-events: none;">Release to Import</div>
    </div>

    <!-- WIDGETS -->
    <div class="overlay-widget stats-widget" id="stats-panel" style="display: none;">
        <span>Pipes: <strong id="stat-pipes" style="color:white">0</strong></span>
        <span style="opacity:0.3; margin: 0 8px;">|</span>
        <span>Fittings: <strong id="stat-fittings" style="color:white">0</strong></span>
        <span style="opacity:0.3; margin: 0 8px;">|</span>
        <span id="status-objects">Obj: 0</span>
    </div>

    <div class="overlay-widget coord-widget" id="coord-display" style="display: none;">
        XYZ: 0, 0, 0
    </div>

    <!-- Legacy / Hidden elements -->
    <input type="file" id="file-input" accept=".json" style="display: none;">
    <div class="tooltip" id="tooltip" style="display: none;"></div>
    <div id="legend-panel" style="display:none;"></div>

    <!-- Three.js Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ==================== GLOBAL STATE ====================
        const state = {
            scene: null,
            camera: null,
            renderer: null,
            controls: null,
            data: null,
            objects: [],
            selectedObject: null,
            hoverObject: null,
            renderMode: 'realistic',
            wireframe: false, // Default OFF
            xray: false,
            feetToUnit: 0.3048,
            gridHelper: null,
            zOffset: 0  // Grid Z position offset
        };

        const systemColors = {
            'FP-Fire Protection Sprinkler': 0xff4444,
            'PL-Soil Pipe-Tr·ª•c': 0x4caf50,
            'PL-Waste Water-Tr·ª•c': 0x2196f3,
            'PL-Waste Water-CƒÉn h·ªô': 0x00bcd4,
            'PL-Vent Pipe-M·∫∑t b·∫±ng': 0xff9800,
            'PL-Vent Pipe-Tr·ª•c': 0xe91e63,
            'PL-Combined Pipe-Tr·ª•c': 0x9c27b0,
            'PL-Rain Water-PV': 0x795548,
            'PL-Soil Pipe-M·∫∑t b·∫±ng': 0x66bb6a,
            'HW-Hot Water': 0xf44336,
            'HW-Hot Water Return': 0xff5722,
            'Default': 0x888888
        };

        // ==================== INITIALIZATION ====================
        function init() {
            initThreeJS();
            initEventListeners();
            animate();
        }

        function initThreeJS() {
            const container = document.getElementById('three-container');

            state.scene = new THREE.Scene();
            // Match background to CSS gradient (approx dark blue) or keep transparent if we want the CSS gradient to show?
            // Three.js canvas covers the background. Better to set clear color to null/alpha 0 to see CSS, 
            // OR set the color to match. Setting alpha 0 allows the nice CSS gradient to shine through.
            state.scene.background = null;

            // Camera
            state.camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                0.01,
                5000
            );
            state.camera.position.set(15, 15, 15);
            state.camera.up.set(0, 0, 1);

            state.renderer = new THREE.WebGLRenderer({
                antialias: true, // Enable for better aesthetics
                alpha: true, // Enable transparency
                powerPreference: 'high-performance'
            });
            state.renderer.setSize(container.clientWidth, container.clientHeight);
            state.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Higher quality
            state.renderer.shadowMap.enabled = true; // Enable shadows for depth
            state.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(state.renderer.domElement);

            // Controls
            state.controls = new THREE.OrbitControls(state.camera, state.renderer.domElement);
            state.controls.enableDamping = true;
            state.controls.dampingFactor = 0.05;
            state.controls.screenSpacePanning = true;
            state.controls.minDistance = 0.5;
            state.controls.maxDistance = 1000;
            state.controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };

            // Lighting - Improved for "Bright/Modern" look
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            state.scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(20, 30, 50);
            dirLight.castShadow = true;
            state.scene.add(dirLight);

            const fillLight = new THREE.DirectionalLight(0xaaccff, 0.3);
            fillLight.position.set(-20, 0, 20);
            state.scene.add(fillLight);

            // Grid (REMOVED per user request)
            // Axes (REMOVED per user request)

            state.raycaster = new THREE.Raycaster();
            state.mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize);
        }

        function initEventListeners() {
            document.getElementById('file-input').addEventListener('change', handleFileSelect);

            const welcomeDropZone = document.getElementById('welcome-drop-zone');
            const viewport = document.getElementById('three-container'); // Use three-container as viewport trigger is better coverage

            welcomeDropZone.addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            // Global Drop Events
            window.addEventListener('dragover', (e) => {
                e.preventDefault();
                document.getElementById('drop-overlay').classList.add('active');
            });

            document.getElementById('drop-overlay').addEventListener('dragleave', (e) => {
                document.getElementById('drop-overlay').classList.remove('active');
            });

            document.getElementById('drop-overlay').addEventListener('drop', (e) => {
                e.preventDefault();
                document.getElementById('drop-overlay').classList.remove('active');
                if (e.dataTransfer.files[0]) processFile(e.dataTransfer.files[0]);
            });

            // Fallback to prevent default browser file opening
            window.addEventListener('drop', (e) => {
                e.preventDefault();
                document.getElementById('drop-overlay').classList.remove('active');
            });

            // Three Interaction
            viewport.addEventListener('mousemove', onMouseMove);
            viewport.addEventListener('click', onMouseClick);
        }

        // ==================== FILE PROCESSING ====================
        function handleFileSelect(e) {
            if (e.target.files[0]) processFile(e.target.files[0]);
        }

        function processFile(file) {
            showLoading('Loading Model...');

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    setTimeout(() => { // Small delay to let UI render loading state
                        loadRevitData(json);
                        hideLoading();
                    }, 100);
                } catch (error) {
                    hideLoading();
                    alert('Error parsing JSON: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function loadRevitData(data) {
            state.data = data;
            state.objects = [];

            // Cleanup existing
            const objectsToRemove = [];
            state.scene.traverse(child => {
                if (child.userData && (child.userData.type === 'pipe' || child.userData.type === 'fitting')) {
                    objectsToRemove.push(child);
                }
            });
            objectsToRemove.forEach(obj => {
                state.scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });

            // Calculate average Z for grid positioning
            let minZ = Infinity, maxZ = -Infinity;
            let avgZ = 0;
            let count = 0;

            if (data.Pipes && Array.isArray(data.Pipes)) {
                data.Pipes.forEach(pipe => {
                    const z1 = parseFloat(pipe.StartPoint.Z) * state.feetToUnit;
                    const z2 = parseFloat(pipe.EndPoint.Z) * state.feetToUnit;
                    minZ = Math.min(minZ, z1, z2);
                    maxZ = Math.max(maxZ, z1, z2);
                    avgZ += (z1 + z2) / 2;
                    count++;
                });
            }

            if (count > 0) {
                avgZ = avgZ / count;
                state.zOffset = avgZ;
                if (state.gridHelper) state.gridHelper.position.z = avgZ;
            }

            // Build fitting lookup with actual geometry endpoints in world space
            const fittingEndpoints = []; // Array of {origin, endpoints: [worldPos, ...]}
            if (data.Fittings && Array.isArray(data.Fittings)) {
                data.Fittings.forEach(fitting => {
                    const t = fitting.Transform;
                    const s = state.feetToUnit;
                    const origin = new THREE.Vector3(
                        parseFloat(t.Origin.X) * s,
                        parseFloat(t.Origin.Y) * s,
                        parseFloat(t.Origin.Z) * s
                    );

                    let connDiams = [0.1];
                    if (fitting.Connectors?.length > 0) {
                        connDiams = fitting.Connectors.map(c => parseFloat(c.Diameter || 0) * s);
                    }
                    const maxDiam = Math.max(...connDiams);
                    const minDiam = Math.min(...connDiams);
                    const radius = maxDiam / 2;
                    const smallRadius = minDiam / 2;

                    const familyName = (fitting.FamilyName || '').toLowerCase();

                    // Compute local-space endpoints of fitting geometry
                    const localEndpoints = [];
                    if (familyName.includes('elbow')) {
                        const arcRadius = radius * 1.5;
                        // Elbow curve: from (-arcRadius, 0, 0) to (0, arcRadius, 0)
                        localEndpoints.push(new THREE.Vector3(-arcRadius, 0, 0));
                        localEndpoints.push(new THREE.Vector3(0, arcRadius, 0));
                    } else if (familyName.includes('cross')) {
                        const halfRun = radius * 2; // runLength/2 (same as Tee)
                        const branchEnd = radius * 2.5; // branchLength (same as Tee)
                        // Run along X
                        localEndpoints.push(new THREE.Vector3(-halfRun, 0, 0));
                        localEndpoints.push(new THREE.Vector3(halfRun, 0, 0));
                        // Branch along +Y and -Y
                        localEndpoints.push(new THREE.Vector3(0, branchEnd, 0));
                        localEndpoints.push(new THREE.Vector3(0, -branchEnd, 0));
                    } else if (familyName.includes('tee')) {
                        const halfRun = radius * 2; // runLength/2
                        const branchEnd = radius * 2.5; // branchLength
                        // Run along X (after rotation z=PI/2, cylinder axis becomes X)
                        localEndpoints.push(new THREE.Vector3(-halfRun, 0, 0));
                        localEndpoints.push(new THREE.Vector3(halfRun, 0, 0));
                        // Branch along -Y
                        localEndpoints.push(new THREE.Vector3(0, -branchEnd, 0));
                    } else {
                        // Default box: half size
                        const halfSize = maxDiam * 1.2 / 2;
                        // Use 6 face centers as endpoints to handle any pipe direction
                        localEndpoints.push(new THREE.Vector3(halfSize, 0, 0));
                        localEndpoints.push(new THREE.Vector3(-halfSize, 0, 0));
                        localEndpoints.push(new THREE.Vector3(0, halfSize, 0));
                        localEndpoints.push(new THREE.Vector3(0, -halfSize, 0));
                        localEndpoints.push(new THREE.Vector3(0, 0, halfSize));
                        localEndpoints.push(new THREE.Vector3(0, 0, -halfSize));
                    }

                    // Build transform matrix (same logic as createFitting)
                    const matrix = new THREE.Matrix4();
                    if (familyName.includes('tee') || familyName.includes('cross')) {
                        const xVal = parseFloat(t.BasisX.X);
                        const yVal = parseFloat(t.BasisX.Y);
                        const angle = Math.atan2(yVal, xVal);
                        const rotMat = new THREE.Matrix4().makeRotationZ(angle);
                        const posMat = new THREE.Matrix4().makeTranslation(origin.x, origin.y, origin.z);
                        matrix.multiplyMatrices(posMat, rotMat);
                    } else {
                        matrix.set(
                            parseFloat(t.BasisX.X), parseFloat(t.BasisY.X), parseFloat(t.BasisZ.X), origin.x,
                            parseFloat(t.BasisX.Y), parseFloat(t.BasisY.Y), parseFloat(t.BasisZ.Y), origin.y,
                            parseFloat(t.BasisX.Z), parseFloat(t.BasisY.Z), parseFloat(t.BasisZ.Z), origin.z,
                            0, 0, 0, 1
                        );
                    }

                    // Transform local endpoints to world space
                    const worldEndpoints = localEndpoints.map(lp => lp.clone().applyMatrix4(matrix));

                    let connectedPipes = [];
                    if (fitting.Connectors && Array.isArray(fitting.Connectors)) {
                        connectedPipes = fitting.Connectors.map(c => String(c.ConnectedToId)).filter(id => id !== "undefined" && id !== "null");
                    }

                    fittingEndpoints.push({ origin, endpoints: worldEndpoints, connectedPipes });
                });
            }

            if (data.Pipes) data.Pipes.forEach((pipe, index) => createPipe(pipe, index, fittingEndpoints));
            if (data.Fittings) data.Fittings.forEach((fitting, index) => createFitting(fitting, index));

            updateProjectBrowser();
            updateSystemFilters();
            updateStats();

            document.getElementById('welcome-screen').style.display = 'none';
            document.getElementById('coord-display').style.display = 'block';

            // Ensure wireframe UI matches state
            document.getElementById('wireframe-btn').classList.toggle('active', state.wireframe);

            fitToView();
            updateColorLegend();
        }

        // ==================== 3D RENDERING ====================
        function createPipe(pipe, index, fittingEndpoints) {
            const scale = state.feetToUnit;

            const start = new THREE.Vector3(
                parseFloat(pipe.StartPoint.X) * scale,
                parseFloat(pipe.StartPoint.Y) * scale,
                parseFloat(pipe.StartPoint.Z) * scale
            );
            const end = new THREE.Vector3(
                parseFloat(pipe.EndPoint.X) * scale,
                parseFloat(pipe.EndPoint.Y) * scale,
                parseFloat(pipe.EndPoint.Z) * scale
            );

            // Shorten pipe ends to match fitting geometry endpoints
            if (fittingEndpoints && fittingEndpoints.length > 0) {
                const pipeDir = new THREE.Vector3().subVectors(end, start).normalize();
                const pipeIdStr = String(pipe.Id);

                for (const fit of fittingEndpoints) {
                    if (!fit.connectedPipes || !fit.connectedPipes.includes(pipeIdStr)) continue;

                    const isStart = start.distanceTo(fit.origin) < end.distanceTo(fit.origin);
                    const checkDir = isStart ? pipeDir : pipeDir.clone().negate();

                    let bestEp = null;
                    let bestDot = -Infinity;
                    for (const ep of fit.endpoints) {
                        const toEp = new THREE.Vector3().subVectors(ep, fit.origin).normalize();
                        const dot = toEp.dot(checkDir);
                        if (dot > bestDot) {
                            bestDot = dot;
                            bestEp = ep;
                        }
                    }
                    if (bestEp && bestDot > 0.5) {
                        const indentDist = fit.origin.distanceTo(bestEp);
                        if (isStart) {
                            start.copy(fit.origin).add(pipeDir.clone().multiplyScalar(indentDist));
                        } else {
                            end.copy(fit.origin).add(pipeDir.clone().negate().multiplyScalar(indentDist));
                        }
                    }
                }
            }

            const diameter = parseFloat(pipe.Diameter) * scale;
            const radius = diameter / 2;
            const length = start.distanceTo(end);

            if (length < 0.001) return;

            const geometry = new THREE.CylinderGeometry(radius, radius, length, 12, 1);
            const color = getSystemColor(pipe.SystemTypeName || 'Default');

            const material = new THREE.MeshLambertMaterial({
                color: color,
                wireframe: state.wireframe
            });

            const mesh = new THREE.Mesh(geometry, material);
            const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            mesh.position.copy(midpoint);

            const direction = new THREE.Vector3().subVectors(end, start).normalize();
            const yAxis = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(yAxis, direction);
            mesh.quaternion.copy(quaternion);

            mesh.userData = {
                type: 'pipe',
                data: pipe,
                id: pipe.Id,
                name: pipe.Id,
                originalMaterial: material
            };

            state.scene.add(mesh);
            state.objects.push(mesh);
        }

        function createFitting(fitting) {
            const transform = fitting.Transform;
            const scale = state.feetToUnit;

            const origin = new THREE.Vector3(
                parseFloat(transform.Origin.X) * scale,
                parseFloat(transform.Origin.Y) * scale,
                parseFloat(transform.Origin.Z) * scale
            );

            let connectorDiameters = [0.1];
            if (fitting.Connectors?.length > 0) {
                connectorDiameters = fitting.Connectors.map(c => parseFloat(c.Diameter || 0) * scale);
            }

            const maxDiameter = Math.max(...connectorDiameters);
            const minDiameter = Math.min(...connectorDiameters);
            const radius = maxDiameter / 2;
            const smallRadius = minDiameter / 2;

            const familyName = (fitting.FamilyName || '').toLowerCase();
            const material = new THREE.MeshLambertMaterial({
                color: getFittingColor(fitting.FamilyName || 'Default'),
                wireframe: state.wireframe
            });

            let mesh;

            // Simplified geometry creation for clarity in refactor
            if (familyName.includes('elbow')) {
                const arcRadius = radius * 1.5;
                const tubeRadius = radius * 0.85;
                const curve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(-arcRadius, 0, 0),
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, arcRadius, 0)
                );
                const geometry = new THREE.TubeGeometry(curve, 16, tubeRadius, 12, false);
                const subMesh = new THREE.Mesh(geometry, material);
                mesh = new THREE.Group();
                mesh.add(subMesh);
            } else if (familyName.includes('cross')) {
                // Cross = 4-way junction
                // Ph√¢n lo·∫°i connector: run (d·ªçc theo BasisX) vs branch (vu√¥ng g√≥c BasisX)
                const group = new THREE.Group();
                const t = fitting.Transform;
                const basisXDir = new THREE.Vector2(parseFloat(t.BasisX.X), parseFloat(t.BasisX.Y)).normalize();

                // Ph√¢n lo·∫°i connectors th√†nh run vs branch d·ª±a tr√™n h∆∞·ªõng pipe
                const runDiams = [];
                const branchDiams = [];

                if (fitting.Connectors && fitting.Connectors.length >= 4) {
                    fitting.Connectors.forEach(conn => {
                        const connDia = parseFloat(conn.Diameter || 0) * scale;
                        const connId = conn.ConnectedToId;

                        // T√¨m pipe t∆∞∆°ng ·ª©ng ƒë·ªÉ x√°c ƒë·ªãnh h∆∞·ªõng
                        let isRun = false;
                        if (connId && state.data && state.data.Pipes) {
                            const pipe = state.data.Pipes.find(p => p.Id === connId);
                            if (pipe) {
                                const ps = new THREE.Vector2(
                                    parseFloat(pipe.StartPoint.X), parseFloat(pipe.StartPoint.Y));
                                const pe = new THREE.Vector2(
                                    parseFloat(pipe.EndPoint.X), parseFloat(pipe.EndPoint.Y));
                                const pipeDir = new THREE.Vector2().subVectors(pe, ps).normalize();
                                // N·∫øu pipe song song v·ªõi BasisX (|dot| > 0.7) ‚Üí run
                                const dot = Math.abs(pipeDir.dot(basisXDir));
                                isRun = dot > 0.7;
                            }
                        }

                        if (isRun) runDiams.push(connDia);
                        else branchDiams.push(connDia);
                    });
                }

                // Fallback n·∫øu ph√¢n lo·∫°i kh√¥ng ƒë·ªß
                const runRadius = runDiams.length > 0 ? Math.max(...runDiams) / 2 : radius;
                const branchRadius1 = branchDiams.length > 0 ? branchDiams[0] / 2 : smallRadius;
                const branchRadius2 = branchDiams.length > 1 ? branchDiams[1] / 2 : branchRadius1;

                // Run along X
                const runLength = runRadius * 4;
                const runGeom = new THREE.CylinderGeometry(runRadius, runRadius, runLength, 12);
                const runMesh = new THREE.Mesh(runGeom, material);
                runMesh.rotation.z = Math.PI / 2;
                group.add(runMesh);

                // Branch +Y
                const branchLength1 = runRadius * 2.5;
                const branchGeom1 = new THREE.CylinderGeometry(branchRadius1, branchRadius1, branchLength1, 12);
                const branchMesh1 = new THREE.Mesh(branchGeom1, material);
                branchMesh1.position.y = branchLength1 / 2;
                group.add(branchMesh1);

                // Branch -Y
                const branchLength2 = runRadius * 2.5;
                const branchGeom2 = new THREE.CylinderGeometry(branchRadius2, branchRadius2, branchLength2, 12);
                const branchMesh2 = new THREE.Mesh(branchGeom2, material);
                branchMesh2.position.y = -branchLength2 / 2;
                group.add(branchMesh2);

                mesh = group;
            } else if (familyName.includes('tee')) {
                const group = new THREE.Group();
                const runLength = radius * 4;
                const runGeom = new THREE.CylinderGeometry(radius, radius, runLength, 12);
                const runMesh = new THREE.Mesh(runGeom, material);
                runMesh.rotation.z = Math.PI / 2;
                group.add(runMesh);

                const branchLength = radius * 2.5;
                const branchGeom = new THREE.CylinderGeometry(smallRadius, smallRadius, branchLength, 12);
                const branchMesh = new THREE.Mesh(branchGeom, material);
                branchMesh.position.y = -branchLength / 2;
                group.add(branchMesh);
                mesh = group;
            } else {
                // Default box
                const size = maxDiameter * 1.2;
                const geometry = new THREE.BoxGeometry(size, size, size);
                mesh = new THREE.Mesh(geometry, material);
            }

            // Debug axis (REMOVED per user request)

            const matrix = new THREE.Matrix4();

            // Fix for Tees: Rely on BasisX only (Z-rotation) as requested by user
            if (familyName.includes('tee') || familyName.includes('cross')) {
                const xVal = parseFloat(transform.BasisX.X);
                const yVal = parseFloat(transform.BasisX.Y);
                const angle = Math.atan2(yVal, xVal);

                const rotationMatrix = new THREE.Matrix4().makeRotationZ(angle);
                const positionMatrix = new THREE.Matrix4().makeTranslation(origin.x, origin.y, origin.z);

                matrix.multiplyMatrices(positionMatrix, rotationMatrix);
            } else {
                // Default handling (Preserves mirroring for Elbows)
                matrix.set(
                    parseFloat(transform.BasisX.X), parseFloat(transform.BasisY.X), parseFloat(transform.BasisZ.X), origin.x,
                    parseFloat(transform.BasisX.Y), parseFloat(transform.BasisY.Y), parseFloat(transform.BasisZ.Y), origin.y,
                    parseFloat(transform.BasisX.Z), parseFloat(transform.BasisY.Z), parseFloat(transform.BasisZ.Z), origin.z,
                    0, 0, 0, 1
                );
            }

            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const meshScale = new THREE.Vector3();
            matrix.decompose(position, quaternion, meshScale);

            mesh.position.copy(position);
            mesh.quaternion.copy(quaternion);
            mesh.scale.copy(meshScale);

            mesh.userData = {
                type: 'fitting',
                data: fitting,
                id: fitting.Id,
                name: fitting.FamilyName || fitting.Id,
                originalMaterial: material
            };

            state.scene.add(mesh);
            state.objects.push(mesh);
        }

        function getSystemColor(systemType) {
            return systemColors[systemType] || systemColors['Default'];
        }

        function getFittingColor(familyName) {
            const name = (familyName || '').toLowerCase();
            if (name.includes('elbow')) return 0x888888;
            if (name.includes('wye')) return 0x999999;
            if (name.includes('cross')) return 0xbbbbbb;
            if (name.includes('tee')) return 0xaaaaaa;
            if (name.includes('sprinkler')) return 0xff6b6b;
            return systemColors['Default'];
        }

        // ==================== UI UPDATES ====================
        function updateProjectBrowser() {
            const browser = document.getElementById('project-browser');
            const pipes = state.data.Pipes?.length || 0;
            const fittings = state.data.Fittings?.length || 0;

            const levels = new Set();
            if (state.data.Pipes) state.data.Pipes.forEach(p => { if (p.LevelName) levels.add(p.LevelName); });
            if (state.data.Fittings) state.data.Fittings.forEach(f => { if (f.LevelName) levels.add(f.LevelName); });
            const sortedLevels = Array.from(levels).sort();

            let html = `
                <label class="tree-item" style="margin-bottom: 2px;">
                    <div class="toggle-switch">
                        <input type="checkbox" checked id="toggle-all-elements" onchange="toggleAllElements(this)">
                        <span class="toggle-slider"></span>
                    </div>
                    <span class="tree-item-icon" style="margin-left: 5px;">üìÅ</span>
                    <span style="flex: 1;">All Elements</span>
                </label>
                <div class="tree-children">
                    <label class="tree-item" style="margin-bottom: 2px;">
                        <div class="toggle-switch">
                            <input type="checkbox" checked data-type="pipe" onchange="toggleTypeFilter(this)">
                            <span class="toggle-slider"></span>
                        </div>
                        <span class="tree-item-icon" style="margin-left: 5px;">üîó</span>
                        <span style="flex: 1;">Pipes (${pipes})</span>
                    </label>
                    <label class="tree-item" style="margin-bottom: 2px;">
                        <div class="toggle-switch">
                            <input type="checkbox" checked data-type="fitting" onchange="toggleTypeFilter(this)">
                            <span class="toggle-slider"></span>
                        </div>
                        <span class="tree-item-icon" style="margin-left: 5px;">üîß</span>
                        <span style="flex: 1;">Fittings (${fittings})</span>
                    </label>
                </div>
                
                <label class="tree-item" style="margin-top: 10px; margin-bottom: 2px;">
                    <div class="toggle-switch">
                        <input type="checkbox" checked id="toggle-all-levels" onchange="toggleAllLevels(this)">
                        <span class="toggle-slider"></span>
                    </div>
                    <span class="tree-item-icon" style="margin-left: 5px;">üè¢</span>
                    <span style="flex: 1;">T·∫ßng (Levels)</span>
                </label>
                <div class="tree-children">
            `;

            if (sortedLevels.length > 0) {
                sortedLevels.forEach(level => {
                    const safeLevel = level.replace(/"/g, '&quot;');
                    html += `
                        <label class="tree-item" style="margin-bottom: 2px;">
                            <div class="toggle-switch">
                                <input type="checkbox" checked data-level="${safeLevel}" onchange="toggleLevelFilter(this)">
                                <span class="toggle-slider"></span>
                            </div>
                            <span style="flex: 1; margin-left: 5px;">${level}</span>
                        </label>
                    `;
                });
            } else {
                html += `
                    <div class="tree-item" style="color: var(--text-muted); cursor: default;">
                        <span>No Levels Data</span>
                    </div>
                `;
            }

            html += `</div>`;

            browser.innerHTML = html;
        }

        function updateSystemFilters() {
            const container = document.getElementById('system-filters');
            const systems = new Set();
            if (state.data.Pipes) state.data.Pipes.forEach(p => { if (p.SystemTypeName) systems.add(p.SystemTypeName); });

            let html = '';
            systems.forEach(system => {
                const color = '#' + getSystemColor(system).toString(16).padStart(6, '0');
                html += `
                    <label class="filter-item" style="margin-bottom: 4px;">
                        <div class="toggle-switch">
                            <input type="checkbox" checked data-system="${system}" onchange="toggleSystemFilter(this)">
                            <span class="toggle-slider"></span>
                        </div>
                        <span class="filter-color" style="background: ${color}; margin-left: 5px;"></span>
                        <span style="flex: 1; margin-left: 5px;">${system}</span>
                    </label>
                `;
            });
            container.innerHTML = html || '<div style="color:var(--text-muted); padding:10px;">No filters</div>';
        }

        function updateStats() {
            const pipes = state.objects.filter(o => o.userData.type === 'pipe').length;
            const fittings = state.objects.filter(o => o.userData.type === 'fitting').length;
            document.getElementById('stat-pipes').textContent = pipes;
            document.getElementById('stat-fittings').textContent = fittings;
            document.getElementById('status-objects').textContent = `Total: ${state.objects.length}`;
            document.getElementById('stats-panel').style.display = 'flex';
        }

        function updateColorLegend() {
            const container = document.getElementById('legend-items');
            const systems = new Set();
            if (state.data.Pipes) state.data.Pipes.forEach(p => { if (p.SystemTypeName) systems.add(p.SystemTypeName); });

            let html = '';
            systems.forEach(system => {
                const color = '#' + getSystemColor(system).toString(16).padStart(6, '0');
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${color};"></div>
                        <span>${system}</span>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function updatePropertiesPanel(object) {
            const panel = document.getElementById('properties-panel');
            if (!object) {
                panel.innerHTML = '<div style="text-align:center; padding: 40px 20px; color: var(--text-muted);">Select element</div>';
                return;
            }

            const data = object.userData.data;
            const mm = 304.8;

            let html = `
                <div class="property-group">
                    <div class="property-group-header">Identity</div>
                    <div class="property-row"><span class="property-name">ID</span><span class="property-value">${data.Id || '-'}</span></div>
                    <div class="property-row"><span class="property-name">Type</span><span class="property-value">${object.userData.type}</span></div>
                    <div class="property-row"><span class="property-name">System</span><span class="property-value">${data.SystemTypeName || '-'}</span></div>
                    ${data.FamilyName ? `<div class="property-row"><span class="property-name">Family</span><span class="property-value">${data.FamilyName}</span></div>` : ''}
                    ${data.LevelName ? `<div class="property-row"><span class="property-name">Level</span><span class="property-value">${data.LevelName}</span></div>` : ''}
                </div>
                
                <div class="property-group">
                    <div class="property-group-header">Geometry</div>
                    ${data.Diameter ? `<div class="property-row"><span class="property-name">Diameter</span><span class="property-value">${(parseFloat(data.Diameter) * mm).toFixed(1)} mm</span></div>` : ''}
                    ${data.StartPoint && data.EndPoint ? (() => {
                    const s = data.StartPoint; const e = data.EndPoint;
                    const len = Math.sqrt(Math.pow(e.X - s.X, 2) + Math.pow(e.Y - s.Y, 2) + Math.pow(e.Z - s.Z, 2)) * mm;
                    return `<div class="property-row"><span class="property-name">Length</span><span class="property-value">${len.toFixed(1)} mm</span></div>`;
                })() : ''}
                </div>
            `;

            if (data.Connectors && Array.isArray(data.Connectors) && data.Connectors.length > 0) {
                html += '<div class="property-group"><div class="property-group-header">Connectors</div>';
                data.Connectors.forEach((c, i) => {
                    const d = parseFloat(c.Diameter || 0) * mm;
                    html += `
                        <div class="property-row" style="background:rgba(255,255,255,0.02)">
                            <span class="property-name">#${i + 1}</span>
                            <span class="property-value">√ò${d.toFixed(1)}</span>
                        </div>
                        <div style="padding:4px 8px; font-size:10px; color:var(--text-muted); text-align:right; border-bottom:1px solid rgba(255,255,255,0.03);">
                            ${c.ConnectorId || '?'} ‚Üí ${c.ConnectedToId || 'None'}
                        </div>
                    `;
                });
                html += '</div>';
            }

            panel.innerHTML = html;
        }

        // ==================== EVENT HANDLERS ====================
        function onMouseMove(event) {
            const container = document.getElementById('three-container');
            const rect = container.getBoundingClientRect();
            state.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            state.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Coord update (optimized)
            const vector = new THREE.Vector3(state.mouse.x, state.mouse.y, 0.5);
            vector.unproject(state.camera);
            const scale = state.feetToUnit * 304.8;
            document.getElementById('coord-display').textContent = `X:${(vector.x * scale).toFixed(0)} Y:${(vector.y * scale).toFixed(0)}`;

            // Hover logic ...
            // (Simplified for response brevity, core logic remains same)
        }

        function onMouseClick(event) {
            state.raycaster.setFromCamera(state.mouse, state.camera);
            const intersects = state.raycaster.intersectObjects(state.objects, true); // Recursive for Groups

            if (intersects.length > 0) {
                // Find the top-level parent that is our "object"
                let target = intersects[0].object;
                while (target.parent && !target.userData.id && target.parent !== state.scene) {
                    target = target.parent;
                }

                // If it's part of a group but the group is the main object
                if (target.parent && target.parent.userData.id) {
                    target = target.parent;
                }

                if (!target.userData.id) return; // Clicked something else?

                // restore old selection
                if (state.selectedObject) {
                    restoreObjectColor(state.selectedObject);
                }

                // New selection
                state.selectedObject = target;
                highlightObject(target);

                updatePropertiesPanel(target);
            } else {
                // Deselect
                if (state.selectedObject) {
                    restoreObjectColor(state.selectedObject);
                    state.selectedObject = null;
                    updatePropertiesPanel(null);
                }
            }
        }

        function highlightObject(object) {
            const highlightColor = 0x40a0ff;
            const emissiveColor = 0x0078d4;

            if (object.isGroup) {
                // First pass: save original colors before any mutation happens
                object.children.forEach(child => {
                    if (child.isMesh) {
                        if (!child.userData.originalColor) child.userData.originalColor = child.material.color.clone();
                    }
                });
                // Second pass: apply highlighting
                object.children.forEach(child => {
                    if (child.isMesh) {
                        child.material.emissive.setHex(emissiveColor);
                        child.material.color.setHex(highlightColor);
                    }
                });
            } else if (object.isMesh) {
                if (!object.userData.originalColor) object.userData.originalColor = object.material.color.clone();
                object.material.emissive.setHex(emissiveColor);
                object.material.color.setHex(highlightColor);
            }
        }

        function restoreObjectColor(object) {
            if (object.isGroup) {
                object.children.forEach(child => {
                    if (child.isMesh) {
                        child.material.emissive.setHex(0x000000);
                        if (child.userData.originalColor) {
                            child.material.color.copy(child.userData.originalColor);
                        } else if (object.userData.originalMaterial) {
                            child.material.color.copy(object.userData.originalMaterial.color);
                        }
                    }
                });
            } else if (object.isMesh) {
                object.material.emissive.setHex(0x000000);
                if (object.userData.originalColor) {
                    object.material.color.copy(object.userData.originalColor);
                } else if (object.userData.originalMaterial) {
                    object.material.color.copy(object.userData.originalMaterial.color);
                }
            }
        }

        function onWindowResize() {
            const container = document.getElementById('three-container');
            state.camera.aspect = container.clientWidth / container.clientHeight;
            state.camera.updateProjectionMatrix();
            state.renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            state.controls.update();
            state.renderer.render(state.scene, state.camera);
        }

        // ==================== ACTIONS ====================
        // ==================== ACTIONS ====================
        function resetCamera() {
            fitToView(); // Unified action
        }

        function fitToView() {
            if (state.objects.length === 0) {
                // Reset to default home if no objects
                state.camera.position.set(15, -15, 15); // 5 o'clockish
                state.camera.lookAt(0, 0, 0);
                state.camera.up.set(0, 0, 1);
                state.controls.target.set(0, 0, 0);
                state.controls.update();
                return;
            }

            const box = new THREE.Box3();
            state.objects.forEach(obj => box.expandByObject(obj));
            const center = new THREE.Vector3();
            box.getCenter(center);
            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);

            // 5 o'clock view: X+, Y-
            // Position: Center + (Distance * Direction)
            const distance = maxDim * 2.0;
            const direction = new THREE.Vector3(1, -1, 0.8).normalize(); // 5 o'clock direction + elevation

            const newPos = center.clone().add(direction.multiplyScalar(distance));

            state.camera.position.copy(newPos);
            state.camera.up.set(0, 0, 1);
            state.camera.lookAt(center);
            state.controls.target.copy(center);
            state.controls.update();
        }

        function toggleWireframe() {
            state.wireframe = !state.wireframe;
            document.getElementById('wireframe-btn').classList.toggle('active', state.wireframe);
            state.objects.forEach(obj => {
                if (obj.isGroup) {
                    obj.children.forEach(child => {
                        if (child.isMesh) child.material.wireframe = state.wireframe;
                    });
                } else if (obj.isMesh) {
                    obj.material.wireframe = state.wireframe;
                }
            });
        }

        function toggleTransparency() {
            state.xray = !state.xray;
            document.getElementById('xray-btn').classList.toggle('active', state.xray);
            state.objects.forEach(obj => {
                if (obj.isGroup) {
                    obj.children.forEach(child => {
                        if (child.isMesh) {
                            child.material.transparent = state.xray;
                            child.material.opacity = state.xray ? 0.5 : 1.0;
                        }
                    });
                } else if (obj.isMesh) {
                    obj.material.transparent = state.xray;
                    obj.material.opacity = state.xray ? 0.5 : 1.0;
                }
            });
        }

        function updateGlobalCheckboxState() {
            const allCheckboxes = document.querySelectorAll('input[type="checkbox"]:not(#toggle-all-elements)');
            const allChecked = Array.from(allCheckboxes).every(cb => cb.checked);
            const toggleAll = document.getElementById('toggle-all-elements');
            if (toggleAll) toggleAll.checked = allChecked;
        }

        function toggleAllElements(checkbox) {
            const visible = checkbox.checked;
            state.objects.forEach(obj => obj.visible = visible);
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = visible);
        }

        function toggleTypeFilter(checkbox) {
            const type = checkbox.dataset.type;
            const visible = checkbox.checked;
            state.objects.forEach(obj => {
                if (obj.userData.type === type) obj.visible = visible;
            });
            updateGlobalCheckboxState();
        }

        function toggleSystemFilter(checkbox) {
            const system = checkbox.dataset.system;
            const visible = checkbox.checked;
            state.objects.forEach(obj => {
                if (obj.userData.data.SystemTypeName === system) obj.visible = visible;
            });
            updateGlobalCheckboxState();
        }

        function toggleLevelFilter(checkbox) {
            const level = checkbox.dataset.level;
            const visible = checkbox.checked;
            state.objects.forEach(obj => {
                if (obj.userData.data.LevelName === level) obj.visible = visible;
            });

            // Update parent checkbox state
            const levelCheckboxes = document.querySelectorAll('input[data-level]');
            const allChecked = Array.from(levelCheckboxes).every(cb => cb.checked);
            const toggleAll = document.getElementById('toggle-all-levels');
            if (toggleAll) toggleAll.checked = allChecked;

            updateGlobalCheckboxState();
        }

        function toggleAllLevels(checkbox) {
            const visible = checkbox.checked;
            const levelCheckboxes = document.querySelectorAll('input[data-level]');
            levelCheckboxes.forEach(cb => {
                cb.checked = visible;
            });

            // Apply visibility to all objects with a LevelName
            state.objects.forEach(obj => {
                if (obj.userData.data.LevelName) {
                    obj.visible = visible;
                }
            });

            updateGlobalCheckboxState();
        }

        function showLoading(text) {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('loading-overlay').classList.add('active');
        }
        function hideLoading() {
            document.getElementById('loading-overlay').classList.remove('active');
        }
        function showStatistics() {
            document.getElementById('stats-panel').style.display = 'flex';
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>