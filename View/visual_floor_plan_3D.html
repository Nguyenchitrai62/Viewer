<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floor Plan Viewer - Realtime Minimap</title>
    <style>
        /* --- GI·ªÆ NGUY√äN CSS C∆† B·∫¢N --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; background: #1a1a2e; overflow: hidden; color: #333; }
        #container { width: 100vw; height: 100vh; position: relative; }
        
        #canvas-container { width: 100%; height: 100%; cursor: default; background: #f0f2f5; }
        
        #drop-zone {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 450px; padding: 50px; background: rgba(255, 255, 255, 0.95);
            border-radius: 16px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3); text-align: center;
            border: 2px dashed #667eea; transition: all 0.3s; z-index: 2000;
        }
        #drop-zone.drag-over { background: #eef2ff; border-color: #2d55ff; transform: translate(-50%, -50%) scale(1.02); }
        #drop-zone.hidden { opacity: 0; pointer-events: none; transform: translate(-50%, -50%) scale(0.9); }
        #drop-zone h2 { color: #333; margin-bottom: 10px; }
        #drop-zone .icon { font-size: 50px; margin-bottom: 20px; display: block; }
        
        #main-panel {
            position: absolute; top: 20px; left: 20px; width: 300px;
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
            border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 1000; display: none; flex-direction: column;
            transition: width 0.3s ease; max-height: 90vh;
        }
        .panel-header {
            padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px 12px 0 0; display: flex; justify-content: space-between;
            align-items: center; cursor: pointer; user-select: none;
        }
        .panel-header h3 { color: white; font-size: 16px; margin: 0; font-weight: 600; }
        .toggle-btn {
            background: rgba(255,255,255,0.2); border: none; color: white; width: 28px; height: 28px;
            border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 18px; line-height: 1; transition: background 0.2s;
        }
        .toggle-btn:hover { background: rgba(255,255,255,0.4); }
        .panel-content { padding: 10px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #cbd5e0 transparent; }
        .panel-content::-webkit-scrollbar { width: 6px; }
        .panel-content::-webkit-scrollbar-thumb { background-color: #cbd5e0; border-radius: 3px; }
        #main-panel.collapsed { width: 180px; }
        #main-panel.collapsed .panel-content { display: none; }
        #main-panel.collapsed .panel-header { border-radius: 12px; }
        
        .section-title { font-size: 11px; text-transform: uppercase; color: #888; letter-spacing: 0.5px; margin: 10px 0 8px 0; padding-bottom: 5px; border-bottom: 1px solid #eee; font-weight: 700; }
        .section-title:first-child { margin-top: 0; }
        .info-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 12px; color: #555; background: #f8f9fa; padding: 8px; border-radius: 8px; border: 1px solid #eee; }
        .info-stats div strong { color: #333; }
        
        .control-group { margin-bottom: 8px; }
        .control-group label { display: flex; justify-content: space-between; font-size: 12px; font-weight: 500; margin-bottom: 3px; }
        input[type="range"] { width: 100%; height: 6px; background: #e2e8f0; border-radius: 3px; appearance: none; outline: none; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 14px; height: 14px; background: #667eea; border-radius: 50%; cursor: pointer; transition: transform 0.1s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        
        .btn-group { display: flex; gap: 8px; margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px; }
        button.action-btn { flex: 1; padding: 6px; background: #f0f4ff; color: #667eea; border: 1px solid #667eea; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 11px; transition: all 0.2s; }
        button.action-btn.active { background: #667eea; color: white; box-shadow: 0 2px 5px rgba(102, 126, 234, 0.4); }

        #loading-popup {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.7); display: none; justify-content: center;
            align-items: center; z-index: 3000; backdrop-filter: blur(5px);
        }
        #loading-popup .content {
            background: white; padding: 30px; border-radius: 12px; text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        #loading-popup .spinner {
            width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #667eea;
            border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #loading-popup h3 { color: #333; margin: 0; }

        /* --- MINI-MAP STYLES --- */
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200;
            height: 200px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #ccc;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        #minimap svg {
            width: 100%;
            height: 100%;
            /* L∆∞·ªõi n·ªÅn m·ªù */
            background-image: 
                linear-gradient(#eee 1px, transparent 1px),
                linear-gradient(90deg, #eee 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .map-house-bounds {
            fill: none;
            stroke: #ddd;
            stroke-width: 1;
            stroke-dasharray: 2, 2;
        }
        .map-camera-line {
            stroke: #333;
            stroke-width: 2;
            stroke-dasharray: 4, 4; 
        }
        .map-target-point {
            fill: #ff4757;
            stroke: white;
            stroke-width: 2;
        }
        .map-camera-icon {
            fill: #2f3542;
            stroke: white;
            stroke-width: 1;
            filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.3));
        }
        #minimap-label {
            position: absolute;
            bottom: 5px; right: 8px;
            font-size: 10px; color: #888;
            font-weight: bold; pointer-events: none;
            background: rgba(255,255,255,0.8);
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <!-- --- MINI-MAP (UPDATED) --- -->
        <div id="minimap">
            <svg id="minimap-svg" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                <!-- 1. ·∫¢nh n·ªÅn 2D g·ªëc -->
                <!-- preserveAspectRatio="none" ƒë·ªÉ kh·ªõp v·ªõi scale c·ªßa 3D -->
                <image id="map-image-layer" x="0" y="0" width="0" height="0" preserveAspectRatio="none" style="display: none;" />

                <!-- 2. Khung vi·ªÅn (Optional) -->
                <rect id="map-house" class="map-house-bounds" x="0" y="0" width="0" height="0" />
                
                <!-- 3. ƒê∆∞·ªùng n·ªëi Camera -> LookAt -->
                <line id="map-line" class="map-camera-line" x1="100" y1="180" x2="100" y2="100" />
                
                <!-- 4. ƒêi·ªÉm LookAt -->
                <circle id="map-target" class="map-target-point" cx="100" cy="100" r="4" />
                
                <!-- 5. Icon Camera -->
                <g id="map-cam-group" transform="translate(100, 180)">
                    <path class="map-camera-icon" d="M-8,5 L8,5 L10,-4 L-10,-4 Z M-4,-4 L0,-10 L4,-4" />
                </g>
            </svg>
            <div id="minimap-label">Camera View</div>
        </div>

        <div id="drop-zone">
            <span class="icon">üìÇ</span>
            <h2>Upload JSON or Image</h2>
            <p>Drag & drop a file here or click to choose</p>
            <input type="file" id="file-input" accept=".json,image/*" style="display: none;">
        </div>
        
        <div id="main-panel">
            <div class="panel-header" id="panel-header">
                <h3>üéõÔ∏è Control Panel</h3>
                <button class="toggle-btn" id="toggle-btn" title="Collapse/Expand">‚àí</button>
            </div>
            
            <div class="panel-content">
                <div class="section-title">File Info</div>
                <div id="stats-content" class="info-stats">
                    <div style="grid-column: span 2; text-align: center;">Waiting for file...</div>
                </div>

                <div class="section-title">3D Dimensions</div>
                <div class="control-group">
                    <label>Wall Height <span id="val-wall-h">80</span></label>
                    <input type="range" id="wall-height" min="50" max="300" value="80">
                </div>
                <div class="control-group">
                    <label>Wall Thickness <span id="val-wall-t">8</span></label>
                    <input type="range" id="wall-thickness" min="5" max="30" value="8" step="0.5">
                </div>

                <div class="section-title">Display</div>
                <div class="btn-group">
                    <button class="action-btn active" id="toggle-walls">Wall</button>
                    <button class="action-btn active" id="toggle-doors">Door</button>
                    <button class="action-btn active" id="toggle-windows">Window</button>
                    <button class="action-btn active" id="toggle-skeleton">Opening</button>
                </div>
                <div class="btn-group">
                    <button class="action-btn" id="toggle-grid">Grid</button>
                    <button class="action-btn active" id="toggle-image" disabled>Image</button>
                </div>

                <div class="section-title">Opacity</div>
                <div class="control-group">
                    <label>Image <span id="val-image-opacity">100</span>%</label>
                    <input type="range" id="image-opacity" min="0" max="100" value="100">
                </div>
                <div class="control-group">
                    <label>3D Objects <span id="val-3d-opacity">80</span>%</label>
                    <input type="range" id="3d-opacity" min="0" max="100" value="80">
                </div>
                <div class="btn-group">
                    <button class="action-btn" id="reset-view">Reset View</button>
                    <button class="action-btn" id="top-view">Top View</button>
                </div>
            </div>
        </div>
    </div>

    <div id="loading-popup">
        <div class="content">
            <div class="spinner"></div>
            <h3>Processing...</h3>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let gridHelper;
        
        let meshes = {
            wall: null,
            opening: null,
            unknown: null,
            rooms: null
        };
        let doorObjects = [];   
        let windowObjects = []; 
        
        let imageMesh = null; 
        let jsonData = null;
        let target = new THREE.Vector3(0, 0, 0); 
        
        let rootGroup;
        let raycaster = new THREE.Raycaster();
        let outlineMesh;
        let lookAtMarker;
        
        // Camera tween state for smooth transitions
        let cameraTween = null; // { start, duration, fromPos, toPos, fromTarget, toTarget }

        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        function animateCameraTo(toPos, toTarget, duration = 750) {
            if (!camera || !target) return;
            cameraTween = {
                start: performance.now(),
                duration: duration,
                fromPos: camera.position.clone(),
                toPos: toPos.clone(),
                fromTarget: target.clone(),
                toTarget: toTarget.clone()
            };
        }
        const TARGET_SIZE = 1000; 
        let processingTime = null; 

        // --- MINI-MAP CONFIG ---
        let mapParams = {
            minX: -500, maxX: 500,
            minZ: -500, maxZ: 500,
            scale: 0.1,
            svgSize: 180,
            padding: 20,
            offsetX: 0,
            offsetY: 0
        };

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }

        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f2f5);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 20000);
            camera.position.set(800, 1000, 800);
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(500, 1000, 500);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -1500;
            dirLight.shadow.camera.right = 1500;
            dirLight.shadow.camera.top = 1500;
            dirLight.shadow.camera.bottom = -1500;
            scene.add(dirLight);
            
            gridHelper = new THREE.GridHelper(2000, 40, 0xbdc3c7, 0xe0e0e0);
            scene.add(gridHelper);
            gridHelper.visible = false;
            
            rootGroup = new THREE.Group();
            scene.add(rootGroup);
            
            outlineMesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.8 })
            );
            outlineMesh.visible = false;
            outlineMesh.matrixAutoUpdate = false;
            scene.add(outlineMesh);
            
            // Add LookAt Marker (Red Sphere)
            const markerGeo = new THREE.SphereGeometry(2, 12, 12);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8, depthTest: false });
            lookAtMarker = new THREE.Mesh(markerGeo, markerMat);
            lookAtMarker.renderOrder = 999; // Always on top
            lookAtMarker.visible = false;
            scene.add(lookAtMarker);

            setupMouseControls();
            window.addEventListener('resize', onWindowResize);
            
            updateMapBounds(null); // Init map
            animate();
        }

        // --- C·∫¨P NH·∫¨T BI√äN D·∫†NG V√Ä ·∫¢NH N·ªÄN CHO MINI-MAP ---
        function updateMapBounds(data) {
            const svg = document.getElementById('minimap-svg');
            const houseRect = document.getElementById('map-house');
            const mapImage = document.getElementById('map-image-layer');
            
            // 1. X√°c ƒë·ªãnh v√πng bao (Bounding Box) c·ªßa d·ªØ li·ªáu 3D
            if (!data) {
                mapParams.minX = -TARGET_SIZE/2; mapParams.maxX = TARGET_SIZE/2;
                mapParams.minZ = -TARGET_SIZE/2; mapParams.maxZ = TARGET_SIZE/2;
                mapImage.style.display = 'none';
            } else {
                // N·∫øu c√≥ imageMesh, d√πng k√≠ch th∆∞·ªõc c·ªßa n√≥ ƒë·ªÉ l√†m chu·∫©n
                if (imageMesh) {
                     const w = imageMesh.geometry.parameters.width * imageMesh.scale.x;
                     const h = imageMesh.geometry.parameters.height * imageMesh.scale.y;
                     // imageMesh ƒë∆∞·ª£c ƒë·∫∑t ·ªü v·ªã tr√≠ x√°c ƒë·ªãnh b·ªüi buildFloorPlan, nh∆∞ng th∆∞·ªùng l√† centered n·∫øu ta set position
                     // Trong buildFloorPlan, imageMesh.position ƒë∆∞·ª£c set.
                     const centerX = imageMesh.position.x;
                     const centerZ = imageMesh.position.z;

                     mapParams.minX = centerX - w/2; 
                     mapParams.maxX = centerX + w/2;
                     mapParams.minZ = centerZ - h/2; 
                     mapParams.maxZ = centerZ + h/2;

                     // L·∫•y source ·∫£nh t·ª´ texture ƒë·ªÉ hi·ªÉn th·ªã l√™n SVG
                     if(imageMesh.material.map && imageMesh.material.map.image) {
                        mapImage.setAttribute('href', imageMesh.material.map.image.src);
                        mapImage.style.display = 'block';
                     }
                } else {
                    // N·∫øu kh√¥ng c√≥ ·∫£nh, d√πng m·∫∑c ƒë·ªãnh
                    mapParams.minX = -TARGET_SIZE/2;
                    mapParams.maxX = TARGET_SIZE/2;
                    mapParams.minZ = -TARGET_SIZE/2;
                    mapParams.maxZ = TARGET_SIZE/2;
                    mapImage.style.display = 'none';
                }
            }

            // 2. T√≠nh t·ª∑ l·ªá Scale (Fit v√πng bao v√†o √¥ vu√¥ng 200x200 c√≥ padding)
            const worldW = mapParams.maxX - mapParams.minX;
            const worldH = mapParams.maxZ - mapParams.minZ;
            const maxDim = Math.max(worldW, worldH) || 1000;
            
            const availSize = mapParams.svgSize - mapParams.padding * 2;
            mapParams.scale = availSize / maxDim;

            // 3. T√≠nh to√°n v·ªã tr√≠ v√† k√≠ch th∆∞·ªõc tr√™n SVG
            const rectW = worldW * mapParams.scale;
            const rectH = worldH * mapParams.scale;
            const rectX = (mapParams.svgSize - rectW) / 2;
            const rectY = (mapParams.svgSize - rectH) / 2;
            
            // Offset n√†y d√πng ƒë·ªÉ mapping t·ªça ƒë·ªô t·ª´ 3D (World) -> SVG
            // C√¥ng th·ª©c: SVG_X = (World_X - minX) * scale + rectX
            // => SVG_X = World_X * scale + (rectX - minX * scale)
            mapParams.offsetX = rectX - (mapParams.minX * mapParams.scale);
            mapParams.offsetY = rectY - (mapParams.minZ * mapParams.scale);

            // 4. C·∫≠p nh·∫≠t th·∫ª <image> trong SVG
            if (mapImage.style.display !== 'none') {
                mapImage.setAttribute('x', rectX);
                mapImage.setAttribute('y', rectY);
                mapImage.setAttribute('width', rectW);
                mapImage.setAttribute('height', rectH);
            }

            // 5. C·∫≠p nh·∫≠t khung vi·ªÅn (Rect)
            houseRect.setAttribute('width', rectW);
            houseRect.setAttribute('height', rectH);
            houseRect.setAttribute('x', rectX);
            houseRect.setAttribute('y', rectY);
        }

        // --- RENDER VISUAL TR√äN MINI-MAP ---
        function updateMiniMap() {
            if (!camera || !target) return;

            // Chuy·ªÉn t·ªça ƒë·ªô 3D -> 2D SVG
            const cx = camera.position.x * mapParams.scale + mapParams.offsetX;
            const cy = camera.position.z * mapParams.scale + mapParams.offsetY;
            
            const tx = target.x * mapParams.scale + mapParams.offsetX;
            const ty = target.z * mapParams.scale + mapParams.offsetY;

            // C·∫≠p nh·∫≠t Icon Camera
            const camGroup = document.getElementById('map-cam-group');
            const dx = tx - cx;
            const dy = ty - cy;
            const angle = Math.atan2(dy, dx) * (180 / Math.PI); 
            // +90 ƒë·ªô v√¨ icon v·∫Ω h∆∞·ªõng l√™n tr√™n (tr·ª•c Y √¢m)
            const rotation = angle + 90; 

            camGroup.setAttribute('transform', `translate(${cx}, ${cy}) rotate(${rotation})`);

            // C·∫≠p nh·∫≠t Target Point
            const targetDot = document.getElementById('map-target');
            targetDot.setAttribute('cx', tx);
            targetDot.setAttribute('cy', ty);

            // C·∫≠p nh·∫≠t Line
            const line = document.getElementById('map-line');
            line.setAttribute('x1', cx);
            line.setAttribute('y1', cy);
            line.setAttribute('x2', tx);
            line.setAttribute('y2', ty);
        }

        function setupMouseControls() {
            let isDragging = false;
            let mouseButton = -1; 
            let previousMouse = { x: 0, y: 0 };
            let hoveredRoom = null; // Track currently hovered room
            const canvasContainer = document.getElementById('canvas-container');

            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
            
            canvasContainer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isDragging = true;
                mouseButton = e.button;
                previousMouse = { x: e.clientX, y: e.clientY };
                if (e.button === 0) {
                    canvasContainer.style.cursor = 'move';
                    if (lookAtMarker) {
                        lookAtMarker.position.copy(target);
                        lookAtMarker.visible = true;
                    }
                } else if (e.button === 2) {
                    // Right click: pan + show lookAt marker as requested
                    canvasContainer.style.cursor = 'grabbing';
                    if (lookAtMarker) {
                        lookAtMarker.position.copy(target);
                        lookAtMarker.visible = true;
                    }
                }
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!isDragging) {
                    const mouse = new THREE.Vector2();
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    let checkObjects = [];
                    Object.values(meshes).forEach(m => { if(m && m.visible) checkObjects.push(m); });
                    if (document.getElementById('toggle-doors').classList.contains('active')) checkObjects.push(...doorObjects);
                    if (document.getElementById('toggle-windows').classList.contains('active')) checkObjects.push(...windowObjects);

                    const intersects = raycaster.intersectObjects(checkObjects, true);
                    
                    if (intersects.length > 0) {
                        const hit = intersects[0];
                        const obj = hit.object;

                        // --- HANDLE ROOM HOVER ---
                        if (obj.userData && obj.userData.isRoom) {
                            // Hide the box outline
                            outlineMesh.visible = false;

                            // If hovering a new room
                            if (hoveredRoom !== obj) {
                                // Reset previous room
                                if (hoveredRoom) {
                                    hoveredRoom.material.opacity = 0.0;
                                    hoveredRoom.material.needsUpdate = true;
                                }
                                // Highlight new room
                                hoveredRoom = obj;
                                hoveredRoom.material.opacity = 0.6; // Make visible
                                hoveredRoom.material.color.setHex(0x66ff66); // Highlight color
                                hoveredRoom.material.needsUpdate = true;
                            }
                        } 
                        // --- HANDLE WALL/DOOR/WINDOW HOVER ---
                        else {
                            // Reset room if we moved away
                            if (hoveredRoom) {
                                hoveredRoom.material.opacity = 0.0;
                                hoveredRoom.material.color.setHex(0xffffff); // Reset color
                                hoveredRoom.material.needsUpdate = true;
                                hoveredRoom = null;
                            }

                            if (hit.instanceId !== undefined && obj.isInstancedMesh) {
                                const matrix = new THREE.Matrix4();
                                obj.getMatrixAt(hit.instanceId, matrix);
                                matrix.premultiply(rootGroup.matrixWorld);
                                outlineMesh.matrix.copy(matrix);
                                outlineMesh.visible = true;
                            } else {
                                let container = obj;
                                while(container.parent && container.parent !== rootGroup) container = container.parent;
                                if (container.userData && container.userData.width) {
                                    const { width, height, depth } = container.userData;
                                    const dummy = new THREE.Object3D();
                                    dummy.position.copy(container.position);
                                    dummy.rotation.copy(container.rotation);
                                    dummy.translateY(height / 2); 
                                    dummy.scale.set(width, height, depth);
                                    dummy.updateMatrix();
                                    const finalMatrix = dummy.matrix.clone();
                                    finalMatrix.premultiply(rootGroup.matrixWorld);
                                    outlineMesh.matrix.copy(finalMatrix);
                                    outlineMesh.visible = true;
                                } else {
                                    outlineMesh.visible = false;
                                }
                            }
                        }
                        outlineMesh.updateMatrixWorld(true);
                    } else {
                        // Nothing hit
                        outlineMesh.visible = false;
                        if (hoveredRoom) {
                            hoveredRoom.material.opacity = 0.0;
                            hoveredRoom.material.color.setHex(0xffffff);
                            hoveredRoom.material.needsUpdate = true;
                            hoveredRoom = null;
                        }
                    }
                }
                
                if (!isDragging) return;
                
                const deltaX = e.clientX - previousMouse.x;
                const deltaY = e.clientY - previousMouse.y;
                
                if (mouseButton === 0) {
                    const offset = new THREE.Vector3().subVectors(camera.position, target);
                    const radius = offset.length();
                    let theta = Math.atan2(offset.x, offset.z);
                    let phi = Math.acos(Math.max(-1, Math.min(1, offset.y / radius)));
                    theta -= deltaX * 0.005;
                    phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.05, phi - deltaY * 0.005));
                    offset.x = radius * Math.sin(phi) * Math.sin(theta);
                    offset.y = radius * Math.cos(phi);
                    offset.z = radius * Math.sin(phi) * Math.cos(theta);
                    camera.position.copy(target).add(offset);
                    camera.lookAt(target);
                } else if (mouseButton === 2) {
                    const distance = camera.position.distanceTo(target);
                    const panSpeed = distance * 0.001;
                    const right = new THREE.Vector3();
                    const up = new THREE.Vector3();
                    camera.matrixWorld.extractBasis(right, up, new THREE.Vector3());
                    const panOffset = new THREE.Vector3().addScaledVector(right, -deltaX * panSpeed).addScaledVector(up, deltaY * panSpeed);
                    panOffset.y = 0; 
                    target.add(panOffset);
                    camera.position.add(panOffset);
                    // If a lookAt marker is visible, update its position to follow the new target
                    if (lookAtMarker && lookAtMarker.visible) {
                        lookAtMarker.position.copy(target);
                    }
                }
                previousMouse = { x: e.clientX, y: e.clientY };
            });
            
            window.addEventListener('mouseup', () => { 
                isDragging = false; 
                mouseButton = -1;
                canvasContainer.style.cursor = 'default'; 
                if(lookAtMarker) lookAtMarker.visible = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 1.1 : 0.9;
                const offset = new THREE.Vector3().subVectors(camera.position, target);
                offset.multiplyScalar(scale);
                offset.clampLength(100, 5000);
                camera.position.copy(target).add(offset);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMiniMap();

            // Process camera tween if active
            if (cameraTween) {
                const now = performance.now();
                const t = Math.min(1, (now - cameraTween.start) / cameraTween.duration);
                const e = easeInOutQuad(t);

                // Lerp position
                camera.position.lerpVectors(cameraTween.fromPos, cameraTween.toPos, e);

                // Lerp target
                target.lerpVectors(cameraTween.fromTarget, cameraTween.toTarget, e);

                camera.lookAt(target);

                // Update lookAtMarker if visible
                if (lookAtMarker && lookAtMarker.visible) lookAtMarker.position.copy(target);

                if (t >= 1) {
                    cameraTween = null;
                }
            }

            // Keep LookAt marker constant size on screen regardless of zoom
            if (lookAtMarker && lookAtMarker.visible) {
                // base radius used when geometry was created
                const baseRadius = 5.0;
                // distance from camera to marker
                const distance = camera.position.distanceTo(lookAtMarker.position);
                // camera vertical field of view (radians)
                const fov = camera.fov * Math.PI / 180.0;
                // approximate world-space height at that distance
                const worldHeight = 2.0 * distance * Math.tan(fov * 0.5);
                // desired marker size in screen pixels (tweakable)
                const desiredPixels = 10.0;
                // convert desired pixel size to world units at this distance
                const worldSize = (desiredPixels * worldHeight) / window.innerHeight;
                // compute uniform scale relative to base geometry radius
                const s = Math.max(0.0001, worldSize / baseRadius);
                lookAtMarker.scale.setScalar(s);
            }

            renderer.render(scene, camera);
        }

        function createDoorGroup(width, height, thickness, wallHeight) {
            const group = new THREE.Group();
            group.userData = { width: width, height: height, depth: thickness };
            const matFrame = new THREE.MeshPhongMaterial({ color: 0x4E342E, transparent: true, opacity: 1.0 }); 
            const matLeaf = new THREE.MeshPhongMaterial({ color: 0x8D6E63, transparent: true, opacity: 1.0 }); 
            const frameW = 4; 
            const leftPost = new THREE.Mesh(new THREE.BoxGeometry(frameW, height, thickness), matFrame);
            leftPost.position.set(-width/2 + frameW/2, height/2, 0);
            const rightPost = new THREE.Mesh(new THREE.BoxGeometry(frameW, height, thickness), matFrame);
            rightPost.position.set(width/2 - frameW/2, height/2, 0);
            const topHeader = new THREE.Mesh(new THREE.BoxGeometry(width, frameW, thickness), matFrame);
            topHeader.position.set(0, height - frameW/2, 0);
            group.add(leftPost, rightPost, topHeader);
            const leafW = width - frameW*2;
            const leafH = height - frameW;
            const leafThick = 4;
            const leaf = new THREE.Mesh(new THREE.BoxGeometry(leafW, leafH, leafThick), matLeaf);
            leaf.position.set(0, leafH/2, 0);
            group.add(leaf);

            // Add wall header above door
            if (wallHeight && wallHeight > height) {
                const headerH = wallHeight - height;
                const matWall = new THREE.MeshPhongMaterial({ color: 0x808080, transparent: true, opacity: 1.0 });
                const header = new THREE.Mesh(new THREE.BoxGeometry(width, headerH, thickness), matWall);
                header.position.set(0, height + headerH / 2, 0);
                group.add(header);
            }

            group.traverse(obj => { if(obj.isMesh) { obj.castShadow = true; obj.receiveShadow = true; } });
            return group;
        }

        function createSlideDoorGroup(width, height, thickness, wallHeight) {
            const group = new THREE.Group();
            group.userData = { width: width, height: height, depth: thickness };
            const matFrame = new THREE.MeshPhongMaterial({ color: 0x3E2723, transparent: true, opacity: 1.0 }); // Darker frame
            const matPanel = new THREE.MeshPhongMaterial({ color: 0xD7CCC8, transparent: true, opacity: 1.0 }); // Lighter panel
            
            const frameW = 4;
            
            // 1. Outer Frame (Jambs)
            const leftJamb = new THREE.Mesh(new THREE.BoxGeometry(frameW, height, thickness), matFrame);
            leftJamb.position.set(-width/2 + frameW/2, height/2, 0);
            const rightJamb = new THREE.Mesh(new THREE.BoxGeometry(frameW, height, thickness), matFrame);
            rightJamb.position.set(width/2 - frameW/2, height/2, 0);
            group.add(leftJamb, rightJamb);

            // 2. Top Track / Header
            const trackH = 6;
            const topTrack = new THREE.Mesh(new THREE.BoxGeometry(width, trackH, thickness + 2), matFrame);
            topTrack.position.set(0, height - trackH/2, 0);
            group.add(topTrack);

            // 3. Bottom Track
            const bottomTrack = new THREE.Mesh(new THREE.BoxGeometry(width, 2, thickness), matFrame);
            bottomTrack.position.set(0, 1, 0);
            group.add(bottomTrack);

            // 4. Panels
            const panelW = (width - frameW*2) / 2 + 2; // Slight overlap
            const panelH = height - trackH - 2;
            
            // Fixed panel (back)
            const fixedPanelGroup = new THREE.Group();
            const fixedPanel = new THREE.Mesh(new THREE.BoxGeometry(panelW, panelH, 4), matPanel);
            const fixedBorder = new THREE.Mesh(new THREE.BoxGeometry(panelW, panelH, 2), matFrame); // Border
            fixedPanelGroup.add(fixedPanel, fixedBorder);
            fixedPanelGroup.position.set(-width/4 + frameW/2, panelH/2 + 2, -2);
            
            // Sliding panel (front)
            const slidePanelGroup = new THREE.Group();
            const slidePanel = new THREE.Mesh(new THREE.BoxGeometry(panelW, panelH, 4), matPanel);
            const slideBorder = new THREE.Mesh(new THREE.BoxGeometry(panelW, panelH, 2), matFrame);
            
            // Vertical handle bar
            const handleH = panelH * 0.4;
            const handle = new THREE.Mesh(new THREE.BoxGeometry(2, handleH, 6), matFrame);
            handle.position.set(panelW/2 - 4, 0, 2); // Relative to group center
            
            slidePanelGroup.add(slidePanel, slideBorder, handle);
            slidePanelGroup.position.set(width/4 - frameW/2, panelH/2 + 2, 2);

            group.add(fixedPanelGroup, slidePanelGroup);

            // 5. Wall Header
            if (wallHeight && wallHeight > height) {
                const headerH = wallHeight - height;
                const matWall = new THREE.MeshPhongMaterial({ color: 0x808080, transparent: true, opacity: 1.0 });
                const header = new THREE.Mesh(new THREE.BoxGeometry(width, headerH, thickness), matWall);
                header.position.set(0, height + headerH / 2, 0);
                group.add(header);
            }
            
            group.traverse(obj => { if(obj.isMesh) { obj.castShadow = true; obj.receiveShadow = true; } });
            return group;
        }

        function createDoubleDoorGroup(width, height, thickness, wallHeight) {
            const group = new THREE.Group();
            group.userData = { width: width, height: height, depth: thickness };
            const matFrame = new THREE.MeshPhongMaterial({ color: 0x3E2723, transparent: true, opacity: 1.0 }); // Dark wood
            const matLeaf = new THREE.MeshPhongMaterial({ color: 0x5D4037, transparent: true, opacity: 1.0 }); // Medium wood
            const matPanel = new THREE.MeshPhongMaterial({ color: 0x8D6E63, transparent: true, opacity: 1.0 }); // Lighter wood for panel
            
            const frameW = 4;
            // Frame posts
            const leftPost = new THREE.Mesh(new THREE.BoxGeometry(frameW, height, thickness), matFrame);
            leftPost.position.set(-width/2 + frameW/2, height/2, 0);
            const rightPost = new THREE.Mesh(new THREE.BoxGeometry(frameW, height, thickness), matFrame);
            rightPost.position.set(width/2 - frameW/2, height/2, 0);
            const topHeader = new THREE.Mesh(new THREE.BoxGeometry(width, frameW, thickness), matFrame);
            topHeader.position.set(0, height - frameW/2, 0);
            group.add(leftPost, rightPost, topHeader);

            // Leaves
            const leafW = (width - frameW*2) / 2 - 0.5; // Small gap in middle
            const leafH = height - frameW;
            const leafThick = 4;
            
            function createLeaf(xPos) {
                const leafGroup = new THREE.Group();
                
                // Stiles and Rails (Border)
                const stileW = leafW * 0.25;
                const railH = leafH * 0.15;
                
                // Vertical Stiles
                const leftStile = new THREE.Mesh(new THREE.BoxGeometry(stileW, leafH, leafThick), matLeaf);
                leftStile.position.set(-leafW/2 + stileW/2, 0, 0);
                
                const rightStile = new THREE.Mesh(new THREE.BoxGeometry(stileW, leafH, leafThick), matLeaf);
                rightStile.position.set(leafW/2 - stileW/2, 0, 0);
                
                // Horizontal Rails
                const topRail = new THREE.Mesh(new THREE.BoxGeometry(leafW - 2*stileW, railH, leafThick), matLeaf);
                topRail.position.set(0, leafH/2 - railH/2, 0);
                
                const bottomRail = new THREE.Mesh(new THREE.BoxGeometry(leafW - 2*stileW, railH, leafThick), matLeaf);
                bottomRail.position.set(0, -leafH/2 + railH/2, 0);
                
                // Center Panel (thinner)
                const panelW = leafW - 2*stileW;
                const panelH = leafH - 2*railH;
                const panel = new THREE.Mesh(new THREE.BoxGeometry(panelW, panelH, leafThick * 0.4), matPanel);
                panel.position.set(0, 0, 0);
                
                leafGroup.add(leftStile, rightStile, topRail, bottomRail, panel);
                leafGroup.position.set(xPos, leafH/2, 0);
                return leafGroup;
            }

            const leftLeaf = createLeaf(-leafW/2 - 0.25);
            const rightLeaf = createLeaf(leafW/2 + 0.25);

            group.add(leftLeaf, rightLeaf);

            // Add wall header above door
            if (wallHeight && wallHeight > height) {
                const headerH = wallHeight - height;
                const matWall = new THREE.MeshPhongMaterial({ color: 0x808080, transparent: true, opacity: 1.0 });
                const header = new THREE.Mesh(new THREE.BoxGeometry(width, headerH, thickness), matWall);
                header.position.set(0, height + headerH / 2, 0);
                group.add(header);
            }
            
            group.traverse(obj => { if(obj.isMesh) { obj.castShadow = true; obj.receiveShadow = true; } });
            return group;
        }

        function createWindowGroup(width, height, thickness, wallHeight) {
            const group = new THREE.Group();
            group.userData = { width: width, height: wallHeight, depth: thickness };
            const matFrame = new THREE.MeshPhongMaterial({ color: 0xFFFFFF, transparent: true, opacity: 1.0 }); 
            const matGlass = new THREE.MeshPhongMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            const matWall = new THREE.MeshPhongMaterial({ color: 0x808080, transparent: true, opacity: 1.0 }); 
            const frameW = 3;
            const bottomHeight = (wallHeight - height) / 2;
            if (bottomHeight > 0) {
                const bottomWall = new THREE.Mesh(new THREE.BoxGeometry(width, bottomHeight, thickness), matWall);
                bottomWall.position.set(0, bottomHeight / 2, 0);
                group.add(bottomWall);
            }
            const topHeight = (wallHeight - height) / 2;
            if (topHeight > 0) {
                const topWall = new THREE.Mesh(new THREE.BoxGeometry(width, topHeight, thickness), matWall);
                topWall.position.set(0, wallHeight - topHeight / 2, 0);
                group.add(topWall);
            }
            const windowY = wallHeight / 2; 
            const vGeo = new THREE.BoxGeometry(frameW, height, thickness);
            const hGeo = new THREE.BoxGeometry(width, frameW, thickness);
            const left = new THREE.Mesh(vGeo, matFrame); left.position.set(-width/2 + frameW/2, windowY, 0);
            const right = new THREE.Mesh(vGeo, matFrame); right.position.set(width/2 - frameW/2, windowY, 0);
            const topFrame = new THREE.Mesh(hGeo, matFrame); topFrame.position.set(0, windowY + height/2 - frameW/2, 0);
            const botFrame = new THREE.Mesh(hGeo, matFrame); botFrame.position.set(0, windowY - height/2 + frameW/2, 0);
            group.add(left, right, topFrame, botFrame);
            const glassW = width - frameW*2;
            const glassH = height - frameW*2;
            const glass = new THREE.Mesh(new THREE.BoxGeometry(glassW, glassH, 2), matGlass);
            glass.position.set(0, windowY, 0);
            group.add(glass);
            const mulThick = 2;
            const vMul = new THREE.Mesh(new THREE.BoxGeometry(mulThick, glassH, thickness), matFrame);
            vMul.position.set(0, windowY, 0);
            const hMul = new THREE.Mesh(new THREE.BoxGeometry(glassW, mulThick, thickness), matFrame);
            hMul.position.set(0, windowY, 0);
            group.add(vMul, hMul);
            group.traverse(obj => { if(obj.isMesh) { obj.castShadow = true; if (!obj.material.transparent) obj.receiveShadow = true; } });
            return group;
        }

        function buildFloorPlan(data) {
            outlineMesh.visible = false;
            Object.keys(meshes).forEach(key => {
                if (meshes[key]) {
                    rootGroup.remove(meshes[key]);
                    if (meshes[key].geometry) meshes[key].geometry.dispose();
                    if (meshes[key].material) meshes[key].material.dispose();
                    if (meshes[key].isGroup) {
                        meshes[key].traverse(child => {
                            if (child.isMesh) {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) child.material.dispose();
                            }
                        });
                    }
                    meshes[key] = null;
                }
            });
            [...doorObjects, ...windowObjects].forEach(obj => {
                rootGroup.remove(obj);
                obj.traverse(child => { if (child.isMesh) child.geometry.dispose(); });
            });
            doorObjects = [];
            windowObjects = [];
            rootGroup.rotation.y = 0;

            if (!data.shapes) return alert("Invalid JSON: missing 'shapes'");

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            let hasData = false;
            let counts = { wall: 0, door: 0, slide_door: 0, double_door: 0, window: 0, opening: 0, unknown: 0 };
            
            data.shapes.forEach(s => {
                if (s.items && s.items[0] && s.items[0].length >= 3) {
                    const [x1, y1] = s.items[0][1];
                    const [x2, y2] = s.items[0][2];
                    minX = Math.min(minX, x1, x2); maxX = Math.max(maxX, x1, x2);
                    minY = Math.min(minY, y1, y2); maxY = Math.max(maxY, y1, y2);
                    hasData = true;
                    let type = (s.type || s.className || 'unknown').toLowerCase().trim().replace(/\s+/g, '');
                    if (type === 'wall') counts.wall++;
                    else if (type === 'door') counts.door++;
                    else if (type === 'slide_door' || type === 'slidedoor') counts.slide_door++;
                    else if (type === 'double_door' || type === 'doubledoor') counts.double_door++;
                    else if (type === 'window') counts.window++;
                    else if (type.includes('skeleton') || type.includes('opening')) counts.opening++;
                    else counts.unknown++;
                }
            });

            if (!hasData) return alert("File JSON kh√¥ng ch·ª©a t·ªça ƒë·ªô h·ª£p l·ªá");

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const maxDimension = Math.max(maxX - minX, maxY - minY) || 1;
            const scaleFactor = TARGET_SIZE / maxDimension;

            // --- ADD ROOM VISUALIZATION ---
            if (data.rooms && data.rooms.length > 0) {
                meshes.rooms = new THREE.Group();
                data.rooms.forEach(roomPoly => {
                    if (roomPoly.length < 3) return;
                    const shape = new THREE.Shape();
                    const startX = (roomPoly[0][0] - centerX) * scaleFactor;
                    const startZ = (roomPoly[0][1] - centerY) * scaleFactor;
                    shape.moveTo(startX, startZ);
                    for (let i = 1; i < roomPoly.length; i++) {
                        const px = (roomPoly[i][0] - centerX) * scaleFactor;
                        const pz = (roomPoly[i][1] - centerY) * scaleFactor;
                        shape.lineTo(px, pz);
                    }
                    shape.closePath();
                    
                    const geometry = new THREE.ShapeGeometry(shape);
                    // Room visual: transparent (invisible) but interactive
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff, 
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.0,
                        depthWrite: false
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = { isRoom: true };
                    mesh.rotation.x = Math.PI / 2; 
                    mesh.position.y = 1.0; // Lift up to avoid z-fighting with image
                    mesh.renderOrder = 10; // Ensure rendered after image
                    meshes.rooms.add(mesh);
                });
                rootGroup.add(meshes.rooms);
            }

            if (imageMesh) {
                const imgW = imageMesh.geometry.parameters.width;
                const imgH = imageMesh.geometry.parameters.height;
                imageMesh.scale.set(scaleFactor, scaleFactor, 1);
                imageMesh.rotation.x = -Math.PI / 2; 
                imageMesh.position.set((imgW/2 - centerX) * scaleFactor, -1, (imgH/2 - centerY) * scaleFactor);
                const btn = document.getElementById('toggle-image');
                btn.disabled = false;
                btn.classList.add('active');
                imageMesh.visible = true;
            }

            const hWall = parseFloat(document.getElementById('wall-height').value);
            const tWall = parseFloat(document.getElementById('wall-thickness').value);
            const cWall = "#808080";

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            
            if (counts.wall > 0 || counts.opening > 0) {
                const mat = new THREE.MeshPhongMaterial({ color: cWall, transparent: true, opacity: 1.0 });
                meshes.wall = new THREE.InstancedMesh(geometry, mat, counts.wall + counts.opening);
                meshes.wall.castShadow = true; meshes.wall.receiveShadow = true;
                rootGroup.add(meshes.wall);
            }
            if (counts.opening > 0) {
                const mat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 1.0 });
                meshes.opening = new THREE.InstancedMesh(geometry, mat, counts.opening);
                rootGroup.add(meshes.opening);
            }
            if (counts.unknown > 0) {
                const mat = new THREE.MeshBasicMaterial({ color: 0x999999, transparent: true, opacity: 0.3, wireframe: true });
                meshes.unknown = new THREE.InstancedMesh(geometry, mat, counts.unknown);
                rootGroup.add(meshes.unknown);
            }

            const dummy = new THREE.Object3D();
            let idx = { wall: 0, opening: 0, unknown: 0 };

            data.shapes.forEach(shape => {
                if (!shape.items || shape.items.length === 0) return;
                const [x1, y1] = shape.items[0][1];
                const [x2, y2] = shape.items[0][2];
                const sx = (x1 - centerX) * scaleFactor;
                const sz = (y1 - centerY) * scaleFactor;
                const ex = (x2 - centerX) * scaleFactor;
                const ez = (y2 - centerY) * scaleFactor;
                const len = Math.sqrt((ex - sx)**2 + (ez - sz)**2);
                if (len < 0.1) return;
                const angle = Math.atan2(ez - sz, ex - sx);
                const midX = (sx + ex)/2;
                const midZ = (sz + ez)/2;
                let type = (shape.type || shape.className || 'unknown').toLowerCase().trim().replace(/\s+/g, '');

                if (type === 'wall') {
                    dummy.position.set(midX, hWall/2, midZ);
                    dummy.rotation.set(0, -angle, 0);
                    dummy.scale.set(len, hWall, tWall);
                    dummy.updateMatrix();
                    meshes.wall.setMatrixAt(idx.wall++, dummy.matrix);
                } else if (type === 'door') {
                    const hDoor = hWall * 0.85; 
                    const doorThickness = 4;
                    const doorGroup = createDoorGroup(len, hDoor, doorThickness, hWall);
                    doorGroup.position.set(midX, 0, midZ);
                    doorGroup.rotation.y = -angle;
                    rootGroup.add(doorGroup);
                    doorObjects.push(doorGroup);
                } else if (type === 'slide_door' || type === 'slidedoor') {
                    const hDoor = hWall * 0.85;
                    const doorThickness = 4;
                    const doorGroup = createSlideDoorGroup(len, hDoor, doorThickness, hWall);
                    doorGroup.position.set(midX, 0, midZ);
                    doorGroup.rotation.y = -angle;
                    rootGroup.add(doorGroup);
                    doorObjects.push(doorGroup);
                } else if (type === 'double_door' || type === 'doubledoor') {
                    const hDoor = hWall * 0.85;
                    const doorThickness = 4;
                    const doorGroup = createDoubleDoorGroup(len, hDoor, doorThickness, hWall);
                    doorGroup.position.set(midX, 0, midZ);
                    doorGroup.rotation.y = -angle;
                    rootGroup.add(doorGroup);
                    doorObjects.push(doorGroup);
                } else if (type === 'window') {
                    const hWin = hWall * 0.5;
                    const winGroup = createWindowGroup(len, hWin, tWall, hWall);
                    winGroup.position.set(midX, 0, midZ);
                    winGroup.rotation.y = -angle;
                    rootGroup.add(winGroup);
                    windowObjects.push(winGroup);
                } else if (type.includes('skeleton') || type.includes('opening')) {
                    const hOpening = hWall * 0.8;
                    const hHeader = hWall - hOpening;

                    // Opening part (wireframe)
                    dummy.position.set(midX, hOpening/2, midZ);
                    dummy.rotation.set(0, -angle, 0);
                    dummy.scale.set(len, hOpening, tWall * 0.5);
                    dummy.updateMatrix();
                    if (meshes.opening) meshes.opening.setMatrixAt(idx.opening++, dummy.matrix);

                    // Header part (wall)
                    if (meshes.wall) {
                        dummy.position.set(midX, hOpening + hHeader/2, midZ);
                        dummy.rotation.set(0, -angle, 0);
                        dummy.scale.set(len, hHeader, tWall);
                        dummy.updateMatrix();
                        meshes.wall.setMatrixAt(idx.wall++, dummy.matrix);
                    }
                } else {
                    dummy.position.set(midX, 2.5, midZ);
                    dummy.rotation.set(0, -angle, 0);
                    dummy.scale.set(len, 5, tWall);
                    dummy.updateMatrix();
                    meshes.unknown.setMatrixAt(idx.unknown++, dummy.matrix);
                }
            });

            if(meshes.wall) meshes.wall.instanceMatrix.needsUpdate = true;
            if(meshes.opening) meshes.opening.instanceMatrix.needsUpdate = true;
            if(meshes.unknown) meshes.unknown.instanceMatrix.needsUpdate = true;

            update3DOpacity(document.getElementById('3d-opacity').value / 100);

            document.getElementById('stats-content').innerHTML = `
                <div><strong>Walls:</strong> ${counts.wall}</div>
                <div><strong>Doors:</strong> ${counts.door}</div>
                <div><strong>Slide Doors:</strong> ${counts.slide_door}</div>
                <div><strong>Double Doors:</strong> ${counts.double_door}</div>
                <div><strong>Windows:</strong> ${counts.window}</div>
                <div><strong>Openings:</strong> ${counts.opening}</div>
                <div><strong>Scale:</strong> ${(1/scaleFactor).toFixed(2)}x</div>
                ${processingTime !== null ? `<div><strong>Time:</strong> ${processingTime}ms</div>` : ''}
            `;
            
            // --- C·∫¨P NH·∫¨T MINI-MAP SAU KHI BUILD XONG ---
            updateMapBounds(data);
        }

        function fitCameraToScene() {
            const toTarget = new THREE.Vector3(0, 0, 0);
            const dist = TARGET_SIZE * 1.2;
            const toPos = new THREE.Vector3(dist * 0.7, dist, dist * 0.7);
            if (rootGroup) rootGroup.rotation.y = 0;
            animateCameraTo(toPos, toTarget);
        }

        let isLoading = false;
        function showLoading() { isLoading = true; document.getElementById('loading-popup').style.display = 'flex'; }
        function hideLoading() { isLoading = false; document.getElementById('loading-popup').style.display = 'none'; }

        async function uploadImage(file) {
            showLoading();
            const dz = document.getElementById('drop-zone');
            const originalText = dz.querySelector('h2').innerText;
            dz.querySelector('h2').innerText = "Processing image...";
            
            const base64 = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 200000);
            const startTime = Date.now();

            try {
                const response = await fetch('https://api.nguyenchitrai.id.vn/process_floor_plan_image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ files: [base64] }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                processingTime = Date.now() - startTime;

                if (data.results && data.results.length > 0) {
                    jsonData = data.results[0];
                    const loader = new THREE.TextureLoader();
                    
                    if (imageMesh) {
                        rootGroup.remove(imageMesh);
                        imageMesh.geometry.dispose();
                        imageMesh.material.dispose();
                        imageMesh = null;
                    }

                    loader.load(base64, (texture) => {
                        const imgW = texture.image.width;
                        const imgH = texture.image.height;
                        const geometry = new THREE.PlaneGeometry(imgW, imgH);
                        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, opacity: 1.0 });
                        imageMesh = new THREE.Mesh(geometry, material);
                        rootGroup.add(imageMesh);

                        document.getElementById('drop-zone').classList.add('hidden');
                        document.getElementById('main-panel').style.display = 'flex';
                        document.getElementById('main-panel').classList.remove('collapsed');
                        gridHelper.visible = false;
                        document.getElementById('toggle-grid').classList.remove('active');

                        buildFloorPlan(jsonData);
                        fitCameraToScene();
                    });

                } else {
                    alert("No floorplan results found.");
                }
            } catch (error) {
                clearTimeout(timeoutId);
                console.error('Error:', error);
                if (error.name === 'AbortError') alert("Request timed out.");
                else alert("API error: " + error.message);
            } finally {
                 dz.querySelector('h2').innerText = originalText;
                 hideLoading();
            }
        }

        function handleFile(file) {
            if (file.type.startsWith('image/')) uploadImage(file);
            else if (file.name.endsWith('.json') || file.type === 'application/json') loadJSON(file);
            else alert("Please select a JSON or image file");
        }

        function loadJSON(file) {
            showLoading();
            processingTime = null;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    if (imageMesh) {
                        rootGroup.remove(imageMesh);
                        imageMesh.geometry.dispose();
                        imageMesh.material.dispose();
                        imageMesh = null;
                    }
                    jsonData = JSON.parse(e.target.result);
                    document.getElementById('drop-zone').classList.add('hidden');
                    document.getElementById('main-panel').style.display = 'flex';
                    gridHelper.visible = true;
                    document.getElementById('toggle-grid').classList.add('active');
                    const imgBtn = document.getElementById('toggle-image');
                    imgBtn.disabled = true;
                    imgBtn.classList.remove('active');
                    buildFloorPlan(jsonData);
                    fitCameraToScene();
                } catch (err) { alert("JSON error: " + err.message); }
                hideLoading();
            };
            reader.readAsText(file);
        }

        function update3DOpacity(opacity) {
            if (meshes.wall && meshes.wall.material) meshes.wall.material.opacity = opacity;
            if (meshes.opening && meshes.opening.material) meshes.opening.material.opacity = opacity;
            if (meshes.unknown && meshes.unknown.material) meshes.unknown.material.opacity = opacity;
            doorObjects.forEach(group => {
                group.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.opacity = opacity;
                    }
                });
            });
            windowObjects.forEach(group => {
                group.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.opacity = opacity;
                    }
                });
            });
        }

        function setupUI() {
            document.addEventListener('dragover', (e) => e.preventDefault());
            document.addEventListener('drop', (e) => {
                e.preventDefault();
                if (isLoading) return;
                if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
            });
            
            const dz = document.getElementById('drop-zone');
            const finput = document.getElementById('file-input');
            dz.onclick = () => { if (!isLoading) finput.click(); };
            finput.onchange = (e) => { if (!isLoading && e.target.files[0]) handleFile(e.target.files[0]); };

            const refresh = () => { if(jsonData) buildFloorPlan(jsonData); };
            const debouncedRefresh = debounce(refresh, 50);

            ['wall-height', 'wall-thickness'].forEach(id => {
                document.getElementById(id).addEventListener('input', (e) => {
                    const valId = id === 'wall-height' ? 'val-wall-h' : 'val-wall-t';
                    document.getElementById(valId).textContent = e.target.value;
                    debouncedRefresh();
                });
            });

            const toggleState = (id, meshOrArray) => {
                const btn = document.getElementById(id);
                const isActive = btn.classList.toggle('active');
                if (Array.isArray(meshOrArray)) {
                    meshOrArray.forEach(obj => { obj.visible = isActive; });
                } else if (meshOrArray) {
                    meshOrArray.visible = isActive;
                }
            };

            document.getElementById('toggle-walls').onclick = () => toggleState('toggle-walls', meshes.wall);
            document.getElementById('toggle-doors').onclick = () => {
                toggleState('toggle-doors', doorObjects);
                if(meshes.unknown) meshes.unknown.visible = document.getElementById('toggle-doors').classList.contains('active');
            };
            document.getElementById('toggle-windows').onclick = () => toggleState('toggle-windows', windowObjects);
            document.getElementById('toggle-skeleton').onclick = () => toggleState('toggle-skeleton', meshes.opening);
            
            document.getElementById('toggle-grid').onclick = () => {
                const btn = document.getElementById('toggle-grid');
                gridHelper.visible = btn.classList.toggle('active');
            };
            
            document.getElementById('toggle-image').onclick = () => {
                const btn = document.getElementById('toggle-image');
                if(imageMesh) imageMesh.visible = btn.classList.toggle('active');
            };

            document.getElementById('image-opacity').addEventListener('input', (e) => {
                const val = e.target.value;
                document.getElementById('val-image-opacity').textContent = val;
                if(imageMesh) imageMesh.material.opacity = val / 100;
            });

            document.getElementById('3d-opacity').addEventListener('input', (e) => {
                const val = e.target.value;
                document.getElementById('val-3d-opacity').textContent = val;
                update3DOpacity(val / 100);
            });

            const panel = document.getElementById('main-panel');
            const toggleBtn = document.getElementById('toggle-btn');
            toggleBtn.onclick = (e) => { e.stopPropagation(); panel.classList.toggle('collapsed'); toggleBtn.textContent = panel.classList.contains('collapsed') ? '+' : '‚àí'; };
            document.getElementById('panel-header').ondblclick = () => toggleBtn.click();

            document.getElementById('reset-view').onclick = fitCameraToScene;
            document.getElementById('top-view').onclick = () => {
                const toTarget = new THREE.Vector3(0, 0, 0);
                const toPos = new THREE.Vector3(0, TARGET_SIZE * 2, 200);
                if (rootGroup) rootGroup.rotation.y = 0;
                animateCameraTo(toPos, toTarget);
            };
        }

        init();
        setupUI();
    </script>
</body>
</html>