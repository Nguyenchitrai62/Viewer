<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DXF Debug Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-app: #09090b;
            --bg-panel: #121214;
            --bg-header: #18181b;
            --border-subtle: #27272a;
            --border-highlight: #3f3f46;
            
            --accent-primary: #00e5ff;   /* Neon Cyan */
            --accent-secondary: #f43f5e; /* Neon Pink */
            --accent-tertiary: #10b981;  /* Neon Green */
            
            --text-main: #e4e4e7;
            --text-muted: #a1a1aa;
            --text-dim: #71717a;

            --font-ui: 'Inter', system-ui, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            height: 100vh;
            background-color: var(--bg-app);
            color: var(--text-main);
            font-family: var(--font-ui);
            font-size: 13px;
        }

        /* --- Sidebar & Layout --- */
        #sidebar {
            width: 380px;
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 10;
            box-shadow: 4px 0 20px rgba(0,0,0,0.4);
        }

        #header {
            padding: 12px 16px;
            background-color: var(--bg-header);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h3 {
            margin: 0;
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        h3::before {
            content: '';
            display: block;
            width: 8px;
            height: 8px;
            background: var(--accent-primary);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--accent-primary);
        }

        #controls {
            padding: 12px;
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: rgba(255,255,255,0.01);
        }

        .control-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        #layers-list {
            flex: 1;
            overflow-y: auto;
            padding: 0; 
        }

        /* --- Scrollbar --- */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-app); }
        ::-webkit-scrollbar-thumb { background: var(--border-highlight); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

        /* --- Buttons & Inputs --- */
        .btn {
            background-color: transparent;
            color: var(--text-muted);
            border: 1px solid var(--border-highlight);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .btn:hover {
            color: var(--accent-primary);
            border-color: var(--accent-primary);
            background: rgba(0, 229, 255, 0.05);
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.1);
        }
        .btn:active { transform: translateY(1px); }

        .file-input-wrapper {
            position: relative;
            flex: 1;
        }
        .file-label {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-app);
            color: var(--text-main);
            border: 1px dashed var(--border-highlight);
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
            text-align: center;
            transition: all 0.2s;
        }
        .file-label:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        input[type="file"] { display: none; }

        /* --- Tree View (High Density) --- */
        .tree-node {
            border-bottom: 1px solid rgba(255,255,255,0.03);
        }
        
        .tree-header {
            display: flex;
            align-items: center;
            padding: 6px 12px; /* Dense but touchable */
            cursor: pointer;
            user-select: none;
            transition: background 0.1s;
        }
        .tree-header:hover { background-color: rgba(255,255,255,0.05); }

        .tree-toggle {
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 6px;
            color: var(--text-dim);
            font-size: 9px;
            transition: color 0.2s;
        }
        .tree-header:hover .tree-toggle { color: var(--text-main); }
        .expanded > .tree-header .tree-toggle { transform: rotate(90deg); }

        .tree-checkbox {
            appearance: none;
            width: 14px;
            height: 14px;
            border: 1px solid var(--border-highlight);
            border-radius: 3px;
            margin-right: 8px;
            background: transparent;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tree-checkbox:checked {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        .tree-checkbox:checked::after {
            content: '‚úî';
            color: #000;
            font-size: 9px;
            font-weight: bold;
        }

        .tree-label {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-main);
        }
        .tree-count {
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--text-dim);
            background: rgba(255,255,255,0.05);
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 8px;
        }

        .tree-children {
            display: none;
            background-color: rgba(0,0,0,0.2);
            box-shadow: inset 0 4px 8px rgba(0,0,0,0.2);
        }
        .tree-node.expanded > .tree-children { display: block; }

        .tree-child-item {
            display: flex;
            align-items: center;
            padding: 4px 12px 4px 34px; /* Indent logic */
            cursor: pointer;
            border-left: 2px solid transparent;
        }
        .tree-child-item:hover {
            background-color: rgba(255,255,255,0.03);
            border-left-color: var(--accent-secondary);
        }
        
        .tree-child-item .tree-label { color: var(--text-muted); }
        .tree-child-item:hover .tree-label { color: var(--text-main); }

        /* --- Main Canvas Area --- */
        #main {
            flex: 1;
            position: relative;
            background-color: #050505; /* Deep black for contrast */
            overflow: hidden;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        #status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(24, 24, 27, 0.9);
            backdrop-filter: blur(4px);
            padding: 6px 12px;
            border-top: 1px solid var(--border-subtle);
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        #coords-display {
            color: var(--accent-primary);
        }

        /* --- Animations --- */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .fade-in { animation: fadeIn 0.3s ease-out; }
    </style>
</head>
<body>

<div id="sidebar">
    <div id="header">
        <h3>DXF Viewer <span style="font-size: 10px; color: var(--text-dim); font-weight: 400; margin-left: auto;">DEBUG MODE</span></h3>
    </div>
    <div id="controls">
        <div class="control-row">
            <div class="file-input-wrapper">
                <label class="file-label">
                    <span>üìÇ Load JSON</span>
                    <input type="file" id="fileInput" accept=".json">
                </label>
            </div>
        </div>
        <div class="control-row">
            <button class="btn" id="btnToggleAll" style="flex:1;">üëÅ Toggle All</button>
            <button class="btn" id="btnCollapseAll" style="flex:1;">DATA_FOLD</button>
        </div>
        <div class="control-row">
             <button class="btn" id="btnFit" style="width: 100%; border-color: var(--accent-tertiary); color: var(--accent-tertiary);">‚õ∂ Fit View</button>
        </div>
    </div>
    <div id="layers-list">
        <!-- Tree will be injected here -->
        <div style="padding: 20px; text-align: center; color: var(--text-dim);">
            <p>No Data Loaded</p>
            <p style="font-size: 11px;">Drop a .json file here</p>
        </div>
    </div>
</div>

<div id="main">
    <canvas id="canvas"></canvas>
    <div id="status-bar">
        <span id="status">Ready</span>
        <span id="coords-display">0.00, 0.00</span>
    </div>
</div>

<script>
    // --- State ---
    let entities = [];
    // Data Structure: 
    // layers = { 
    //   "LayerName": { 
    //      visible: true, 
    //      expanded: false, 
    //      count: 0, 
    //      subTypes: { 
    //          "BlockNameOrType": { visible: true, count: 0 } 
    //      } 
    //   } 
    // }
    let layers = {}; 
    let transform = { x: 0, y: 0, scale: 1.0 };
    let isDragging = false;
    let lastMousePosition = { x: 0, y: 0 };
    
    // --- CAD Colors (AutoCAD Color Index simplified) ---
    const ACI_COLORS = [
        "#000000", "#FF3333", "#FFFF33", "#33FF33", "#33FFFF", "#3333FF", "#FF33FF", "#FFFFFF",
        "#808080", "#C0C0C0" 
    ];
    // Enhanced neon palette mapping for debug visibility against dark bg
    function getCadColor(colorIndex) {
        if (colorIndex === 1) return "#ff4d4d"; // Red -> Bright Red
        if (colorIndex === 2) return "#ffff4d"; // Yellow -> Bright Yellow
        if (colorIndex === 3) return "#4dff4d"; // Green -> Neon Green
        if (colorIndex === 4) return "#4dffff"; // Cyan -> Neon Cyan
        if (colorIndex === 5) return "#4d4dff"; // Blue -> Bright Blue
        if (colorIndex === 6) return "#ff4dff"; // Magenta -> Neon Magenta
        if (colorIndex === 7) return "#ffffff"; // White
        
        if (colorIndex === 8) return "#808080";
        if (colorIndex === 9) return "#C0C0C0";
        if (colorIndex >= 250 && colorIndex <= 255) return "#999999"; 
        if (colorIndex === 256) return "BYLAYER"; // Should resolve to layer color ideally, defaulting to Gray
        return "#CCCCCC"; 
    }

    // --- DOM Elements ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');
    const layersListEl = document.getElementById('layers-list');
    const statusEl = document.getElementById('status');
    const coordsEl = document.getElementById('coords-display');

    // --- Resize Canvas ---
    function resizeCanvas() {
        // Use devicePixelRatio for sharp rendering on retina
        const dpr = window.devicePixelRatio || 1;
        const rect = document.getElementById('main').getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        ctx.scale(dpr, dpr);
        requestRender();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- Input Handling ---
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        readFile(file);
    });

    const dropZone = document.body;
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, e => {
            e.preventDefault();
            e.stopPropagation();
        }, false);
    });

    dropZone.addEventListener('dragover', () => {
        dropZone.style.boxShadow = "inset 0 0 50px rgba(0,229,255,0.2)";
    });
    dropZone.addEventListener('dragleave', () => {
        dropZone.style.boxShadow = "none";
    });

    dropZone.addEventListener('drop', (e) => {
        dropZone.style.boxShadow = "none";
        const files = e.dataTransfer.files;
        if (files.length > 0) readFile(files[0]);
    }, false);

    function readFile(file) {
        statusEl.textContent = "Loading...";
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const json = JSON.parse(event.target.result);
                loadData(json);
            } catch (err) {
                alert('Error parsing JSON: ' + err);
                statusEl.textContent = "Error parsing JSON";
            }
        };
        reader.readAsText(file);
    }

    // --- Data Processing & Optimization ---
    function loadData(data) {
        // Flatten entities immediately for faster iteration
        // and separate by Layer -> Color -> Type for batching
        entities = [];
        data.forEach(ent => flattenEntity(ent, entities));
        
        layers = {};
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasGeometry = false;

        // Pre-process for bounds and layer structure
        entities.forEach(ent => {
             const l = ent.layer || "0";
             const sub = ent.sub_type || ent.type;

             if (!layers[l]) {
                 // Restored subTypes for tree view compatibility
                 layers[l] = { visible: true, count: 0, items: [], subTypes: {}, expanded: false };
             }
             layers[l].count++;
             layers[l].items.push(ent);

             // SubType tracking for Tree View
             if (!layers[l].subTypes[sub]) {
                 layers[l].subTypes[sub] = { visible: true, count: 0 };
             }
             layers[l].subTypes[sub].count++;

             // Bounds Calculation
             const check = (x, y) => {
                 if(x<minX)minX=x; if(x>maxX)maxX=x;
                 if(y<minY)minY=y; if(y>maxY)maxY=y;
                 hasGeometry = true;
             };
             
             if (ent.type === "LINE") {
                 check(ent.start[0], ent.start[1]);
                 check(ent.end[0], ent.end[1]);
             } else if (ent.type === "LWPOLYLINE" || ent.type === "POLYLINE") {
                 ent.points?.forEach(p => check(p[0], p[1]));
             } else if (ent.type === "CIRCLE" || ent.type === "ARC") {
                 const r = ent.radius || 0;
                 check(ent.center[0]-r, ent.center[1]-r);
                 check(ent.center[0]+r, ent.center[1]+r);
             } else if (ent.type === "INSERT" || ent.type === "TEXT" || ent.type === "MTEXT") {
                 if (ent.insert) check(ent.insert[0], ent.insert[1]);
             }
             else if (ent.type === "SOLID" || ent.type === "TRACE") {
                 ent.points?.forEach(p => check(p[0], p[1]));
             }
             // Ellipse bounds approx
             else if (ent.type === "ELLIPSE") {
                 if (ent.center && ent.major_axis) {
                     const r = Math.hypot(ent.major_axis[0], ent.major_axis[1]);
                     check(ent.center[0]-r, ent.center[1]-r);
                     check(ent.center[0]+r, ent.center[1]+r);
                 }
             }
        });

        renderLayerTree();
        if (hasGeometry && minX !== Infinity) {
            fitView(minX, minY, maxX, maxY);
        } else {
            statusEl.textContent = `Loaded ${entities.length} entities.`;
            requestRender();
        }
    }

    function flattenEntity(ent, list) {
        // Push self
        list.push(ent);
        // Recurse children
        if (ent.children && ent.children.length > 0) {
            ent.children.forEach(child => flattenEntity(child, list));
        }
    }

    // --- High Performance Rendering ---
    function render() {
        // Use native transform for speed (GPU acceleration friendly)
        const dpr = window.devicePixelRatio || 1;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Apply View Transform
        // Canvas Y is down, DXF Y is up. We flip Y via scale(s, -s)
        // Transform: x' = tx + x*s, y' = ty - y*s
        // Matrix: [s, 0, 0, -s, tx, ty]
        ctx.setTransform(
            transform.scale * dpr, 
            0, 
            0, 
            -transform.scale * dpr, 
            transform.x * dpr, 
            transform.y * dpr
        );

        // Constant line width in screen pixels
        // If we want 1px screen width, world width = 1 / scale
        const lineWidth = 1.0 / transform.scale;
        ctx.lineWidth = lineWidth;

        // --- Viewport Culling ---
        // Calculate visible world bounds
        const viewL = (0 - transform.x) / transform.scale;
        const viewR = (canvas.width / dpr - transform.x) / transform.scale;
        const viewT = (transform.y - 0) / transform.scale; // Y is inverted in transform
        const viewB = (transform.y - canvas.height / dpr) / transform.scale;
        
        // Correct min/max since Y is flipped: viewT > viewB usually in world Y?
        // Transform: y_screen = ty - y_world * s 
        // y_world = (ty - y_screen) / s
        // Top screen (0) -> max World Y
        // Bottom screen (h) -> min World Y
        const worldMinX = viewL;
        const worldMaxX = viewR;
        const worldMinY = Math.min(viewT, viewB);
        const worldMaxY = Math.max(viewT, viewB);

        // Optimization: Group by Color to reduce state changes
        const batches = {}; 

        for (let lName in layers) {
            const lState = layers[lName];
            if (!lState.visible) continue;
            
            for (let i = 0; i < lState.items.length; i++) {
                const ent = lState.items[i];
                if (ent.children && ent.children.length > 0) continue; 
                
                // --- Simple Culling ---
                // Skip if completely outside view
                // For lines/polys we check bounding box approx
                let ex1, ey1, ex2, ey2;
                
                if (ent.type === "LINE") {
                    ex1 = Math.min(ent.start[0], ent.end[0]);
                    ex2 = Math.max(ent.start[0], ent.end[0]);
                    ey1 = Math.min(ent.start[1], ent.end[1]);
                    ey2 = Math.max(ent.start[1], ent.end[1]);
                } else if (ent.type === "LWPOLYLINE" || ent.type === "POLYLINE" || ent.type === "SOLID" || ent.type === "TRACE") {
                    // Quick check first point (optimization: ideally pre-calc bounds at load time)
                    if (ent.points && ent.points.length > 0) {
                        // Just checking first point is dangerous but fast. 
                        // Let's implement robust pre-calc bounds later if needed.
                        // For now, accept overhead of iterating points or skip culling for complex?
                        // Let's do a fast lazy check:
                        // If entity doesn't have cached bounds, compute them once?
                        if (!ent._bounds) {
                            let mx=Infinity, Mx=-Infinity, my=Infinity, My=-Infinity;
                            for(let p of ent.points) {
                                if(p[0]<mx)mx=p[0]; if(p[0]>Mx)Mx=p[0];
                                if(p[1]<my)my=p[1]; if(p[1]>My)My=p[1];
                            }
                            ent._bounds = {mx, Mx, my, My};
                        }
                        ex1 = ent._bounds.mx; ex2 = ent._bounds.Mx;
                        ey1 = ent._bounds.my; ey2 = ent._bounds.My;
                    }
                } else if (ent.type === "CIRCLE" || ent.type === "ARC" || ent.type === "ELLIPSE") {
                     // Conservatively usage center +/- radius (or major axis)
                     let r = ent.radius || 0;
                     if(ent.type==="ELLIPSE") r = Math.hypot(ent.major_axis[0], ent.major_axis[1]);
                     ex1 = ent.center[0] - r; ex2 = ent.center[0] + r;
                     ey1 = ent.center[1] - r; ey2 = ent.center[1] + r;
                } else if (ent.type === "TEXT" || ent.type === "MTEXT" || ent.type === "INSERT") {
                     if(ent.insert) {
                         // Approx size
                         const h = ent.height || 100; // heuristic
                         ex1 = ent.insert[0]; ex2 = ent.insert[0] + (ent.width || h*5);
                         ey1 = ent.insert[1]; ey2 = ent.insert[1] + h; 
                         // Just check point for single inserts
                         // Let's allow margin
                     }
                }

                // Intersection test
                if (ex1 !== undefined) {
                    if (ex2 < worldMinX || ex1 > worldMaxX || ey2 < worldMinY || ey1 > worldMaxY) {
                        continue; // Cull
                    }
                }
                
                // ... Batch Processing Logic ...
                let colorKey = ent.color || 256;
                if (!batches[colorKey]) batches[colorKey] = { paths: [], circles: [], texts: [], solids: [], bulges: [] };
                const b = batches[colorKey];
                
                if (ent.type === "LINE") {
                    b.paths.push(ent.start[0], ent.start[1], ent.end[0], ent.end[1]);
                } else if (ent.type === "LWPOLYLINE" || ent.type === "POLYLINE") {
                   if (ent.points && ent.points.length > 0) {
                        const hasBulge = ent.points.some(p => p.length >= 3 && p[2] !== 0);
                        if (hasBulge) b.bulges.push(ent);
                        else b.paths.push(ent); 
                   }
                } else if (ent.type === "CIRCLE") {
                    b.circles.push(ent);
                } else if (ent.type === "ARC" || ent.type === "ELLIPSE" || ent.type === "SPLINE") {
                    b.bulges.push(ent); 
                } else if (ent.type === "SOLID" || ent.type === "TRACE") {
                    b.solids.push(ent);
                } else if (ent.type === "TEXT" || ent.type === "MTEXT") {
                    b.texts.push(ent);
                } else if (ent.type === "INSERT") {
                    b.texts.push({ type: "MARKER", insert: ent.insert });
                }
            }
        }

        // Render Batches
        for (let cKey in batches) {
            const batch = batches[cKey];
            const color = getCadColor(parseInt(cKey) || 256); // Simple resolver
            ctx.strokeStyle = color;
            ctx.fillStyle = color;

            // 1. Batch Lines (Simple Segments)
            // Use one beginPath for ALL disconnected lines? Yes.
            if (batch.paths.length > 0) {
                ctx.beginPath();
                for (let i = 0; i < batch.paths.length; i++) {
                    const item = batch.paths[i];
                    if (typeof item === 'number') {
                        // It's x1, y1, x2, y2 form
                        if (i+3 < batch.paths.length) {
                             ctx.moveTo(item, batch.paths[i+1]);
                             ctx.lineTo(batch.paths[i+2], batch.paths[i+3]);
                             i += 3;
                        }
                    } else {
                        // It's a polyline object
                        const pts = item.points;
                        if (pts.length > 0) {
                            ctx.moveTo(pts[0][0], pts[0][1]);
                            for (let j = 1; j < pts.length; j++) ctx.lineTo(pts[j][0], pts[j][1]);
                            if (item.closed) ctx.closePath();
                        }
                    }
                }
                ctx.stroke();
            }

            // 2. Circles (Native Arc)
            if (batch.circles.length > 0) {
                ctx.beginPath();
                for (let ent of batch.circles) {
                    ctx.moveTo(ent.center[0] + ent.radius, ent.center[1]);
                    ctx.arc(ent.center[0], ent.center[1], ent.radius, 0, 2*Math.PI);
                }
                ctx.stroke();
            }

            // 3. Solids (Filled)
            if (batch.solids.length > 0) {
                ctx.beginPath();
                for (let ent of batch.solids) {
                    if (ent.points && ent.points.length) {
                        ctx.moveTo(ent.points[0][0], ent.points[0][1]);
                        for(let k=1; k<ent.points.length; k++) ctx.lineTo(ent.points[k][0], ent.points[k][1]);
                        ctx.closePath();
                    }
                }
                ctx.fill();
            }

            // 4. Complex Geometry (Arcs, Bulges, Splines, Ellipses)
            // Harder to batch perfectly, loop individually but share style
            if (batch.bulges.length > 0) {
                batch.bulges.forEach(ent => drawComplex(ent, ctx));
            }

            // 5. Texts (Needs transform reset for pixel size/non-deformation?)
            // DXF Text usually scales with zoom.
            // If we want readable text regardless of zoom? No, CAD text scales.
            if (batch.texts.length > 0) {
                 batch.texts.forEach(ent => drawText(ent, ctx, lineWidth));
            }
        }
    }

    // Helper for complex shapes (slow path, but less freq than lines)
    function drawComplex(ent, ctx) {
        ctx.beginPath();
        if (ent.type === "ARC") {
            // angles in degrees. DXF CCW. Canvas CCW.
            // But Y is flipped (-y). 
            // World Angle theta maps to Screen Angle -theta.
            // World CCW maps to Screen CW.
            // We are using `ctx.scale(1, -1)` so standard drawing commands work in +Y up logic!
            // Wait. ctx.scale(..., -scale). 
            // If we draw (10, 10), it goes to screen pixel (X, Height-Y).
            // So +Y is UP.
            // So standard geometry works! ARC angles (CCW) work naturally!
            // We don't need to negate angles if the transform handles the flip.
            
            ctx.arc(ent.center[0], ent.center[1], ent.radius, ent.start_angle*Math.PI/180, ent.end_angle*Math.PI/180);
        } 
        else if (ent.type === "ELLIPSE") {
             // context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise)
             // center, major_axis.
             const mx = ent.major_axis[0];
             const my = ent.major_axis[1];
             const rMaj = Math.hypot(mx, my);
             const rMin = rMaj * ent.ratio;
             const rot = Math.atan2(my, mx);
             ctx.ellipse(ent.center[0], ent.center[1], rMaj, rMin, rot, ent.start_param, ent.end_param);
        }
        else if (ent.type === "LWPOLYLINE" || ent.type === "POLYLINE") {
             // Bulge rendering with native transform
             drawBulgePolylineNative(ctx, ent.points, ent.closed);
        }
        else if (ent.type === "SPLINE") {
             if(ent.control_points?.length){
                 ctx.moveTo(ent.control_points[0][0], ent.control_points[0][1]);
                 for(let i=1; i<ent.control_points.length; i++) ctx.lineTo(ent.control_points[i][0], ent.control_points[i][1]);
             }
        }
        ctx.stroke();
    }

    function drawBulgePolylineNative(ctx, points, closed) {
        if (!points.length) return;
        ctx.moveTo(points[0][0], points[0][1]);
        for (let i=0; i<points.length; i++) {
             if (i === points.length-1 && !closed) break;
             const p1 = points[i];
             const p2 = points[(i+1)%points.length];
             const bulge = p1.length >= 3 ? p1[2] : 0;
             if (bulge === 0) {
                 ctx.lineTo(p2[0], p2[1]);
             } else {
                 const arc = bulgeToArc(
                    {x: p1[0], y: p1[1]}, 
                    {x: p2[0], y: p2[1]}, 
                    bulge
                );
                if (arc) {
                    // Native arc call works with our transform
                    // But check angles range. `arc` returns absolute angles?
                    // bulge > 0 is CCW.
                    ctx.arc(arc.cx, arc.cy, arc.radius, arc.startAngle, arc.endAngle, !arc.ccw);
                } else {
                    ctx.lineTo(p2[0], p2[1]);
                }
             }
        }
    }

    function drawText(ent, ctx, lineWidth) {
        if (ent.type === "MARKER") {
             ctx.fillRect(ent.insert[0]-5*lineWidth, ent.insert[1]-5*lineWidth, 10*lineWidth, 10*lineWidth);
             return;
        }
        
        // Text Logic
        ctx.save();
        ctx.translate(ent.insert[0], ent.insert[1]);
        if(ent.rotation) ctx.rotate(ent.rotation * Math.PI / 180);
        
        // Ensure text is right-side up?
        // In DXF world, text is drawn naturally.
        // Our transform is standard cartesian (+Y up). 
        // Text should verify OK.
        
        // Scale text to have constant screen size OR world size?
        // DXF text height is in World Units.
        // So we just use that.
        // However, Canvas font size is pixels.
        // If we set `ctx.font = "10px"`, it means 10 units in transformed space!
        // So `ent.height` works directly.
        
        // IMPORTANT: Canvas renders text upside down if scale Y is negative?
        // We used `scale(s, -s)`. The text will be mirrored upside down!
        // We must flip Y locally for text to read correctly.
        ctx.scale(1, -1); 
        
        ctx.font = `${ent.height}px monospace`;
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fillText(ent.text || "", 0, 0);
        
        ctx.restore();
    }

    // --- Dropping Old Draw Logic ---
    // Removed old drawEntity, w2s in rendering loop (w2s still useful for mouse hit test)


    function renderLayerTree() {
        layersListEl.innerHTML = '';
        const sortedLayers = Object.keys(layers).sort();

        sortedLayers.forEach(layerName => {
            const layerState = layers[layerName];
            
            // Container
            const node = document.createElement('div');
            node.className = `tree-node ${layerState.expanded ? 'expanded' : ''} fade-in`;

            // Header
            const header = document.createElement('div');
            header.className = 'tree-header';
            
            // Toggle Icon
            const toggle = document.createElement('div');
            toggle.className = 'tree-toggle';
            toggle.textContent = '‚ñ∂'; // CSS animation handles rotation
            toggle.onclick = (e) => {
                e.stopPropagation();
                layerState.expanded = !layerState.expanded;
                renderLayerTree(); // Re-render to update classes/icons
            };

            // Checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'tree-checkbox';
            checkbox.checked = layerState.visible;
            checkbox.onclick = (e) => {
                e.stopPropagation();
                const v = e.target.checked;
                layerState.visible = v;
                // Propagate to all children
                for(let sub in layerState.subTypes) {
                    layerState.subTypes[sub].visible = v;
                }
                renderLayerTree();
                requestRender();
            };
            
            // Label
            const label = document.createElement('span');
            label.className = 'tree-label';
            label.textContent = layerName;
            label.title = layerName; // Tooltip
            label.onclick = () => {
                 layerState.expanded = !layerState.expanded;
                 renderLayerTree();
            };

            const count = document.createElement('span');
            count.className = 'tree-count';
            count.textContent = layerState.count;

            header.appendChild(toggle);
            header.appendChild(checkbox);
            header.appendChild(label);
            header.appendChild(count);
            node.appendChild(header);

            // Children Container
            const childrenContainer = document.createElement('div');
            childrenContainer.className = 'tree-children';
            
            // Sort SubTypes
            const subTypes = Object.keys(layerState.subTypes).sort();
            subTypes.forEach(sub => {
                const subState = layerState.subTypes[sub];
                
                const item = document.createElement('div');
                item.className = 'tree-child-item';

                const subCb = document.createElement('input');
                subCb.type = 'checkbox';
                subCb.className = 'tree-checkbox';
                subCb.checked = subState.visible;
                subCb.onclick = (e) => {
                    e.stopPropagation();
                    subState.visible = e.target.checked;
                    // Check parent state
                    const allVals = Object.values(layerState.subTypes).map(s => s.visible);
                    if (allVals.every(v => v)) layerState.visible = true;
                    // else if (allVals.every(v => !v)) layerState.visible = false;
                    // Keep parent largely independent or just simple reflection
                    
                    renderLayerTree(); 
                    requestRender();
                };

                const subLabel = document.createElement('span');
                subLabel.className = 'tree-label';
                subLabel.textContent = sub;
                subLabel.title = sub;
                
                const subCount = document.createElement('span');
                subCount.className = 'tree-count';
                subCount.textContent = subState.count;

                item.appendChild(subCb);
                item.appendChild(subLabel);
                item.appendChild(subCount);
                childrenContainer.appendChild(item);
            });

            node.appendChild(childrenContainer);
            layersListEl.appendChild(node);
        });
    }

    // --- Rendering ---
    function requestRender() {
        window.requestAnimationFrame(render);
    }

    function render() {
        const dpr = window.devicePixelRatio || 1;
        // Clear logic for transformed context? 
        // Simplest: Reset transform, clear, Apply transform.
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Transparent to show CSS bg
        
        ctx.restore();

        entities.forEach(ent => {
            const lName = ent.layer || "0";
            const lState = layers[lName];
            
            if (!lState) return; 
            
            const sub = ent.sub_type || ent.type;
            const subState = lState.subTypes[sub];

            if (!subState || !subState.visible) return;

            // Determine Color
            let strokeStyle = '#CCCCCC'; 
            const c = ent.color;
            if (c !== undefined && c !== null && c !== 256) {
                strokeStyle = getCadColor(c);
            } else {
                strokeStyle = '#E0E0E0';
            }

            ctx.lineWidth = 1; // 1px on HiDPI might look thin, but "Drafting" precise
            ctx.strokeStyle = strokeStyle;
            ctx.fillStyle = strokeStyle;

            drawEntity(ent, ctx);
        });
    }

    // --- Geometry Helpers ---
    function bulgeToArc(p1, p2, bulge) {
        if (bulge === 0) return null;
        
        const theta = 4 * Math.atan(bulge);
        const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const radius = dist / (2 * Math.sin(Math.abs(theta) / 2));
        const alpha = Math.abs(radius * Math.cos(theta / 2));
        
        // Find center
        // Midpoint
        const mx = (p1.x + p2.x) / 2;
        const my = (p1.y + p2.y) / 2;
        
        // Perpendicular vector
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        
        // Direction depends on bulge sign
        // bulge > 0: CCW, center on left
        // bulge < 0: CW, center on right
        const sign = bulge > 0 ? 1 : -1;
        
        // Distance from midpoint to center
        // Sagitta s = |r (1 - cos(theta/2))| = |radius - alpha|? 
        // Simple geometry: r^2 = (d/2)^2 + h^2. h is dist from chord to center.
        // center is at `alpha` distance from midpoint perpendicular to chord?
        // No. 
        // r^2 = alpha^2 + (d/2)^2 ?? No.
        
        // Alternative: Center calculation from 2 points and bulge
        // https://github.com/lezard-visual/dxf-parser/blob/master/lib/math.js
        
        // Let's use simple geometric construction
        const u = dist; // chord length
        const b = Math.abs(bulge) * u / 2; // sagitta (arc height) NOT QUITE. bulge = tan(theta/4)
        // sagitta = |bulge| * (u/2) is correct only if bulge is ratio. It is not.
        
        // radius R = (u^2/4 + h^2) / 2h 
        // where h is sagitta = u/2 * bulge  <-- actual definition of bulge is tan(theta/4) = 2h/u
        const h = Math.abs(bulge * u / 2);
        
        // Direction perpendicular
        // Normal (-dy, dx)
        const len = Math.hypot(dx, dy);
        const nx = -dy / len;
        const ny = dx / len;
        
        // R calculated above `radius`. 
        
        // Distance from midpoint to center is (R - h) if sweep < 180, (h - R) if sweep > 180?
        // Let's stick to vector math.
        
        // radius^2 = (d/2)^2 + (R-h)^2 ?
        
        // Alternative method:
        // alpha = angle of chord line
        // beta = (pi/2 - theta/2) (base angle of isosceles triangle center-p1-p2)
        // No, let's look up standard implementation.
        
        // w = b * (d/2) ?? No.
        
        // Correct vector offset from midpoint:
        // R = (d/2) * (1 + b^2) / (2b)  (signed radius? relative to sagitta?)
        // Let b = bulge
        // R = | (d/2) * (b^2 + 1) / (2b) | ??
        
        // Simplified: 
        // cot(theta/2) = (1/b - b)/2 ??
        
        // Let's rely on standard formula:
        // Center C = M + (cot(theta/2) * d/2) * Normal
        // bulge = tan(theta/4)
        // cot(theta/2) = (1 - b^2) / (2b)
        
        const cot_half_theta = (1 - bulge*bulge) / (2*bulge);
        const cx = mx + cot_half_theta * (dx/2) * -ny - cot_half_theta * (dy/2) * nx; // Wait, normal rotation
        // Normal (-dy, dx)
        // cx = mx - cot * (dy/2)
        // cy = my + cot * (dx/2)
        
        const cX = mx - cot_half_theta * (dy/2);
        const cY = my + cot_half_theta * (dx/2);
        
        const startAng = Math.atan2(p1.y - cY, p1.x - cX);
        const endAng = Math.atan2(p2.y - cY, p2.x - cX);
        
        // Radius re-check
        const R = Math.hypot(p1.x - cX, p1.y - cY);
        
        return { cx: cX, cy: cY, radius: R, startAngle: startAng, endAngle: endAng, ccw: bulge > 0 };
    }

    function drawBulgePolyline(ctx, points, closed) {
        if (points.length === 0) return;
        
        ctx.beginPath();
        const p0 = w2s(points[0][0], points[0][1]);
        ctx.moveTo(p0.x, p0.y);
        
        for (let i = 0; i < points.length; i++) {
            if (i === points.length - 1 && !closed) break;
            
            const pStart = points[i];
            const pEnd = points[(i + 1) % points.length];
            
            // Format: [x, y, bulge]
            const bulge = pStart.length >= 3 ? pStart[2] : 0;
            
            const s = w2s(pStart[0], pStart[1]);
            const e = w2s(pEnd[0], pEnd[1]);
            
            if (bulge === 0) {
                ctx.lineTo(e.x, e.y);
            } else {
                // We need world coords for arc calc to be precise, then transform result? 
                // Scaling circular arcs is safe for uniform scale.
                // Bulge is invariant scale.
                
                // Calculate arc in WORLD space to get correct angles, then draw in SCREEN space?
                // Yes, because Y-flip in w2s might mess up CW/CCW logic slightly if not careful.
                const arc = bulgeToArc(
                    {x: pStart[0], y: pStart[1]}, 
                    {x: pEnd[0], y: pEnd[1]}, 
                    bulge
                );
                
                if (arc) {
                    const center = w2s(arc.cx, arc.cy);
                    const radius = arc.radius * transform.scale;
                    
                    // Angles need Y-flip correction?
                    // In w2s, y flips.
                    // Math.atan2(y, x) -> Math.atan2(-y, x) = -angle
                    // So world angles theta -> -theta in screen space.
                    // CCW in world (bulge > 0) -> CW in screen (since Y points down)
                    
                    let sa = -arc.startAngle;
                    let ea = -arc.endAngle;
                    let counterClockwise = !!arc.ccw; // World CCW
                    
                    // Canvas arc:
                    // context.arc(x, y, radius, startAngle, endAngle, counterclockwise)
                    // Canvas Y is down. 
                    // To match World CCW (standard Cartesian), we usually flip drawing logic.
                    // If World CCW, Canvas is CW.
                    
                    ctx.arc(center.x, center.y, radius, sa, ea, counterClockwise); 
                } else {
                    ctx.lineTo(e.x, e.y);
                }
            }
        }
        if (closed) {
            // Check last closing logic handled in loop? 
            // The loop goes to N-1. If closed, we handle (N-1) -> 0.
            // Loop condition `i < points.length`.
            // If closed, `(i+1)%len` wraps. correct.
            // If !closed, `break` covers it.
        }
        ctx.stroke();
    }

    function drawEntity(ent, ctx) {
        // Recursive children (e.g. from Blocks/Inserts)
        if (ent.children && ent.children.length > 0) {
             // If parent has specific logic (like color inheritance), handle it?
             // Virtual entities from ezdxf usually have resolved colors or BYBLOCK resolved.
             // We can just draw them.
             ent.children.forEach(child => drawEntity(child, ctx));
             return; // Skip drawing the "container" if it has geometry
        }

        if (ent.type === "LINE") {
            if(ent.start && ent.end) {
                const p1 = w2s(ent.start[0], ent.start[1]);
                const p2 = w2s(ent.end[0], ent.end[1]);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
        }
        else if (ent.type === "LWPOLYLINE" || ent.type === "POLYLINE") {
            if (ent.points && ent.points.length > 0) {
                // Check if any point has bulge != 0
                const hasBulge = ent.points.some(p => p.length >= 3 && p[2] !== 0);
                if (hasBulge) {
                    drawBulgePolyline(ctx, ent.points, ent.closed);
                } else {
                    ctx.beginPath();
                    const p0 = w2s(ent.points[0][0], ent.points[0][1]);
                    ctx.moveTo(p0.x, p0.y);
                    for (let i = 1; i < ent.points.length; i++) {
                        const pi = w2s(ent.points[i][0], ent.points[i][1]);
                        ctx.lineTo(pi.x, pi.y);
                    }
                    if (ent.closed) {
                        ctx.closePath();
                    }
                    ctx.stroke();
                }
            }
        }
        else if (ent.type === "CIRCLE") {
            if(ent.center) {
                const c = w2s(ent.center[0], ent.center[1]);
                const r = ent.radius * transform.scale;
                ctx.beginPath();
                ctx.arc(c.x, c.y, r, 0, 2 * Math.PI);
                ctx.stroke();
            }
        }
        else if (ent.type === "ARC") {
            if(ent.center) {
                const c = w2s(ent.center[0], ent.center[1]);
                const r = ent.radius * transform.scale;
                let startAngle = ent.start_angle * Math.PI / 180;
                let endAngle = ent.end_angle * Math.PI / 180;
                // Invert angles for Canvas Y-down
                ctx.beginPath();
                ctx.arc(c.x, c.y, r, -startAngle, -endAngle, true); 
                ctx.stroke();
            }
        }
        else if (ent.type === "ELLIPSE") {
            // start/end param are in radians (eccentric anomaly maybe? standard DXF is radians)
            if(ent.center && ent.major_axis) {
                const c = w2s(ent.center[0], ent.center[1]);
                // Major axis vector in screen space
                // We need to account for scale and Y-flip
                const mx = ent.major_axis[0] * transform.scale;
                const my = -ent.major_axis[1] * transform.scale; 
                const radiusX = Math.hypot(mx, my);
                const radiusY = radiusX * ent.ratio;
                const rotation = Math.atan2(my, mx);
                
                // DXF params are 0 to 2pi usually
                let startParam = ent.start_param; 
                let endParam = ent.end_param;
                
                // Ellipse uses rotation.
                ctx.beginPath();
                // context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise)
                // Note: start/end params in DXF are eccentric anomaly, same as Canvas?
                // Yes usually.
                // We need to invert rotation sign? 
                // If rotation is computed from screen space vectors, it's already correct relative to screen X.
                
                // NOTE: Canvas ellipse angles work differently if clockwise/ccw is involved with Y-flip
                // Let's rely on standard CCW in screen space.
                // startParam is likely CCW in World. In Screen (Y-flip), it becomes CW?
                
                ctx.ellipse(c.x, c.y, radiusX, radiusY, rotation, -startParam, -endParam, true);
                ctx.stroke();
            }
        }
        else if (ent.type === "SPLINE") {
            if(ent.control_points && ent.control_points.length > 0) {
                 ctx.beginPath();
                 const p0 = w2s(ent.control_points[0][0], ent.control_points[0][1]);
                 ctx.moveTo(p0.x, p0.y);
                 for (let i = 1; i < ent.control_points.length; i++) {
                     const pi = w2s(ent.control_points[i][0], ent.control_points[i][1]);
                     ctx.lineTo(pi.x, pi.y);
                 }
                 ctx.stroke();
                 // If we had real spline weights/knots we'd do better, but flattened polyline is OK
            }
        }
        else if (ent.type === "SOLID" || ent.type === "TRACE") {
            if (ent.points && ent.points.length >= 3) {
                 ctx.beginPath();
                 const p0 = w2s(ent.points[0][0], ent.points[0][1]);
                 ctx.moveTo(p0.x, p0.y);
                 // 0, 1, 2, 3? Solids usually 0,1,2,3 or 0,1,3,2 crossing?
                 // DXF SOLID is 0,1,2 for triangle. 0,1,2,3 for quad.
                 // The point order in DXF is: 0, 1, 2. If 4 points: 0, 1, 2, 3? 
                 // Actually 0, 1, 3, 2 is common Z-shape for TriStrip in rare cases but standard SOLID is 0,1,2,3 or 0,1,2,2.
                 
                 for (let i = 1; i < ent.points.length; i++) {
                     const pi = w2s(ent.points[i][0], ent.points[i][1]);
                     ctx.lineTo(pi.x, pi.y);
                 }
                 ctx.closePath();
                 ctx.fill(); // Solids are filled
            }
        }

        else if (ent.type === "TEXT" || ent.type === "MTEXT") {
            if(ent.insert) {
                if (ent.height * transform.scale < 4) { 
                    const p = w2s(ent.insert[0], ent.insert[1]);
                    ctx.fillRect(p.x, p.y, 2, 2);
                } else {
                    const p = w2s(ent.insert[0], ent.insert[1]);
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    // Rotation
                    let rot = ent.rotation || 0;
                    ctx.rotate(-rot * Math.PI / 180); // Y flip = negate rotation
                    ctx.font = `${Math.max(10, ent.height * transform.scale)}px monospace`;
                    ctx.fillStyle = ctx.strokeStyle; // Use same color
                    ctx.fillText(ent.text || "", 0, 0);
                    ctx.restore();
                }
            }
        }
        else if (ent.type === "INSERT") {
            if(ent.insert) {
                const p = w2s(ent.insert[0], ent.insert[1]);
                ctx.fillStyle = "rgba(0, 229, 255, 0.7)"; 
                ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
            }
        }
    }

    // --- Transforms ---
    function w2s(x, y) {
        return {
            x: transform.x + x * transform.scale,
            y: transform.y - y * transform.scale
        };
    }
    
    function s2w(sx, sy) {
        return {
            x: (sx - transform.x) / transform.scale,
            y: (transform.y - sy) / transform.scale
        };
    }

    // --- Controls ---
    function fitView(minX, minY, maxX, maxY) {
        if (minX === Infinity) return;
        const width = maxX - minX;
        const height = maxY - minY;
        
        // Use visible area of canvas
        const rect = document.getElementById('main').getBoundingClientRect();
        const pad = 50;
        
        const s = Math.min((rect.width - pad*2) / width, (rect.height - pad*2) / height);
        
        transform.scale = s;
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        transform.x = (rect.width / 2) - (cx * s);
        transform.y = (rect.height / 2) + (cy * s); // + because Y is inverted (-y)
        
        requestRender();
    }
    
    document.getElementById('btnToggleAll').addEventListener('click', () => {
        // Toggle based on first layer
        const keys = Object.keys(layers);
        if(keys.length === 0) return;
        const newState = !layers[keys[0]].visible;
        
        for(let k in layers) {
            layers[k].visible = newState;
            for(let s in layers[k].subTypes) {
                layers[k].subTypes[s].visible = newState;
            }
        }
        renderLayerTree();
        requestRender();
    });

    document.getElementById('btnCollapseAll').addEventListener('click', () => {
        for(let k in layers) layers[k].expanded = false;
        renderLayerTree();
    });

    document.getElementById('btnFit').addEventListener('click', () => {
         let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
         let found = false;
         entities.forEach(ent => {
             const l = layers[ent.layer];
             if(!l) return;
             const sub = l.subTypes[ent.sub_type || ent.type];
             if(!sub || !sub.visible) return;

             // Check geometry (simplified)
             const check = (x,y) => {
                 if(x<minX)minX=x; if(x>maxX)maxX=x;
                 if(y<minY)minY=y; if(y>maxY)maxY=y;
                 found=true;
             };
             if(ent.start) { check(ent.start[0],ent.start[1]); check(ent.end[0],ent.end[1]); }
             if(ent.insert) { check(ent.insert[0],ent.insert[1]); }
             if(ent.points) { ent.points.forEach(p=>check(p[0],p[1])); }
             if(ent.center) { 
                 const r = ent.radius||0; 
                 check(ent.center[0]-r, ent.center[1]-r); 
                 check(ent.center[0]+r, ent.center[1]+r); 
             }
         });
         
         if(found) fitView(minX, minY, maxX, maxY);
    });

    // Mouse Interaction
    canvas.addEventListener('mousedown', e => {
        isDragging = true;
        lastMousePosition = { x: e.clientX, y: e.clientY };
    });
    
    window.addEventListener('mousemove', e => {
        // Update Coordinates
        const rect = canvas.getBoundingClientRect();
        if(e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {
             const mx = e.clientX - rect.left;
             const my = e.clientY - rect.top;
             const worldPos = s2w(mx, my);
             coordsEl.textContent = `${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}`;
        }
        
        if (isDragging) {
            const dx = e.clientX - lastMousePosition.x;
            const dy = e.clientY - lastMousePosition.y;
            transform.x += dx;
            transform.y += dy;
            lastMousePosition = { x: e.clientX, y: e.clientY };
            requestRender();
        }
    });

    window.addEventListener('mouseup', () => isDragging = false);
    // canvas.addEventListener('mouseleave', () => isDragging = false); // Let drag continue outside if mouse held

    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        const rect = document.getElementById('main').getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        
        const wx = (mx - transform.x) / transform.scale;
        const wy = (my - transform.y) / -transform.scale;

        transform.scale *= factor;
        
        transform.x = mx - wx * transform.scale;
        transform.y = my + wy * transform.scale;
        requestRender();
    });

</script>
</body>
</html>
